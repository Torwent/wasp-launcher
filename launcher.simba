{$DEFINE SCRIPT_ID := 'd563990c-4d31-4aba-b214-18e69171ed5e'}
{$DEFINE SCRIPT_REVISION := '49'}

{.$DEFINE DEVELOPER_MODE}


{$DEFINE WS_LAUNCHER}{$DEFINE WL_UTILS}{$DEFINE SRL_UTILS}

{$IFNDEF WS_HINTS}
  {$IFDEF HINTS}{$DEFINE WS_HINTS}{$ENDIF}
  {$HINTS OFF}
{$ENDIF}

const
  SIMBA_DATA_DIR = AppPath + 'Data' + DirectorySeparator;
  WL_DATAPATH = SIMBA_DATA_DIR + 'WaspLib' + DirectorySeparator;
  LAUNCHER_DATA = SIMBA_DATA_DIR + 'wasp-launcher' + DirectorySeparator;
  WINAPI_CC = {$IFDEF CPU386}'stdcall'{$ELSE}'win64'{$ENDIF};

type
  TSRL = record IsSetup: Boolean; end;

var
  SRL: TSRL;
  ScriptName: String := ExtractFileName(ScriptFile).Before(ExtractFileExt(ScriptFile));

{$IFNDEF SCRIPT_ID}{$DEFINE SCRIPT_ID := 'd563990c-4d31-4aba-b214-18e69171ed5e'}{$ENDIF}
{$IFNDEF SCRIPT_REVISION}{$DEFINE SCRIPT_REVISION := '1'}{$ENDIF}


{$IFNDEF SRL_TIME_INCLUDED}        
{$DEFINE SRL_TIME_INCLUDED}


(*
# Time
Time related methods
*)
type
  TTimeFormat = (Time_Formal, Time_Short, Time_Abbrev, Time_Bare, Time_FStop, Time_Formal_Long);

const
  ONE_SECOND     = 1000;
  ONE_MINUTE     = ONE_SECOND * 60;
  FIVE_MINUTES   = ONE_MINUTE * 5;
  THIRTY_MINUTES = ONE_MINUTE * 30;
  ONE_HOUR       = ONE_MINUTE * 60;
  ONE_DAY        = ONE_HOUR   * 24;
  
  
(*
## srl.MsToTime
```pascal
function TSRL.MsToTime(const MS: UInt64; const Format: TTimeFormat): String; constref;
```
Converts milliseconds to a string following the given time-format.
*)
function TSRL.MsToTime(const MS: UInt64; const Format: TTimeFormat): String; constref;
var
  STA: array [0..5] of TVariantArray;
  Time: TIntegerArray;
  i, t, tl: Integer;
begin
  Result := '';

  if (Format = TIME_FORMAL_LONG) then
  begin
    tl := 7;
    t := 6;
    SetLength(Time, tl);
    ConvertTime64(MS, Time[0], Time[1], Time[2], Time[3], Time[4], Time[5], Time[6]);
  end else begin
    tl := 3;
    t := 2;
    SetLength(Time, tl);
    ConvertTime(MS, Time[0], Time[1], Time[2]);
  end;

  STA[Ord(Time_Formal)] := [' Hours, ', ' Minutes and ', ' Seconds', False, 0];
  STA[Ord(Time_Short)]  := ['h ', 'm ', 's', False, 2];
  STA[Ord(Time_Abbrev)] := [' hr ', ' min ', ' sec', False, 0];
  STA[Ord(Time_Bare)]   := [':', ':', '', True, 2];
  STA[Ord(Time_FStop)]  := ['.', '.', '', True, 2];
  STA[Ord(Time_Formal_Long)] := [' Years, ', ' Months, ', ' Weeks, ', ' Days, ', ' Hours, ', ' Minutes and ', ' Seconds', False, 0];

  for i := 0 to t do
    if (Time[i] > 0) or (STA[Ord(Format)][tl]) or (i = t) then
      Result += PadZ(IntToStr(Time[i]), STA[Ord(Format)][tl+1]) + STA[Ord(Format)][i];
end;
  
(*
## srl.TimeRunning
```pascal
function TSRL.TimeRunning(TheType: TTimeFormat = Time_Formal_Long): String; constref;
```
Returns time the script has been running as a string with the given time-format.
*)
function TSRL.TimeRunning(TheType: TTimeFormat = Time_Formal_Long): String; constref;
begin
  Result := MsToTime(GetTimeRunning(), TheType);
end;

function TSRL.TimeStamp(): String;
var
  Time: Int64;
  Hours, Mins, Secs, Millis: Int32;
begin
  Time := GetTimeRunning();

  Hours  := Time div 3600000;
  Time   := Time mod 3600000;
  Mins   := Time div 60000;
  Time   := Time mod 60000;
  Secs   := Time div 1000;
  Millis := Time mod 1000;

  Result := Format('[%.2d:%.2d:%.2d:%.3d]', [Hours, Mins, Secs, Millis]);
end;

(*
## TCountDown
A neat and simple timer type.

Example:
```pascal
myTimer.Init(3000); //3000ms
while not myTimer.IsFinished() do
  {do something};

myTimer.Restart(Random(-200,200)); //3000 +/- 200ms
while not myTimer.IsFinished() do
  {do something};
```
*)
type
  TCountDown = record
    Length: UInt64;
    Timeout: UInt64;
    Paused: UInt64;
  end;

procedure TCountDown.Setup(Time: UInt32);
begin
  Self.Length  := Time;
  Self.Timeout := GetTickCount();
  Self.Paused := 0;
end;

procedure TCountDown.Init(Time: UInt32);
begin
  Self.Length  := Time;
  Self.Timeout := GetTickCount() + Time;
  Self.Paused := 0;
end;

procedure TCountDown.Restart(Rand: Int32 = 0);
begin
  if Self.Length > 0 then
  begin
    Self.Paused := 0;
    Self.Timeout := GetTickCount() + (Length + Rand);
  end;
end;

procedure TCountDown.Extend(Time: UInt32);
begin
  Self.Timeout := Self.Timeout + Time;
end;

function TCountDown.TimeRemaining(): UInt32;
begin
  if Self.IsPaused() then
    Result := Max(Self.Timeout - Self.Paused, 0)
  else
    Result := Max(Self.Timeout - GetTickCount(), 0);
end;

function TCountDown.IsFinished(): Boolean;
begin
  Result := (Self.Timeout > 0) and (Self.Paused = 0) and (TimeRemaining() = 0);
end;

function TCountDown.IsPaused(): Boolean;
begin
  Result := Self.Paused > 0;
end;

procedure TCountDown.Pause();
begin
  if not Self.IsPaused() then
    Self.Paused := GetTickCount();
end;

procedure TCountDown.Resume();
begin
  if Self.IsPaused() then
  begin
    Self.Timeout := Self.Timeout + (GetTickCount() - Self.Paused);
    Self.Paused := 0;
  end;
end;

(*
## TStopWatch
A neat and simple stopwatch type.

Example:
```pascal
var StopWatch: TStopWatch;

StopWatch.Start();
Wait(1000);
WriteLn(StopWatch.ElapsedTime()); // ~1000
```
*)
type
  TStopwatch = record
    StartTime: UInt64;
    PausedTime: UInt64;
    TotalPausedTime: UInt64;
  end;

procedure TStopWatch.Start();
begin
  if Self.PausedTime > 0 then
  begin
    Self.TotalPausedTime += GetTickCount() - Self.PausedTime;
    Self.PausedTime := 0;
  end else
    Self.StartTime := GetTickCount();
end;

procedure TStopWatch.Resume();
begin
  Self.Start();
end;

procedure TStopWatch.Pause();
begin
  Self.PausedTime := GetTickCount();
end;

procedure TStopWatch.Reset();
begin
  Self.StartTime := GetTickCount();
  Self.PausedTime := 0;
  Self.TotalPausedTime := 0;
end;

function TStopWatch.ElapsedTime(): UInt64;
begin
  if Self.PausedTime > 0 then
    Result := (GetTickCount() - Self.StartTime) - (GetTickCount() - Self.PausedTime)
  else
    Result := (GetTickCount() - Self.StartTime) - Self.TotalPausedTime;
end;

function TStopWatch.IsPaused(): Boolean;
begin
  Result := Self.PausedTime > 0;
end;

{$IFDEF WINDOWS}
function PerformanceTimer(): Double;
var
  frequency,counter: ^UInt64;
  function QPF(F: ^UInt64): LongBool; static; external 'QueryPerformanceFrequency@Kernel32.dll ' + WINAPI_CC;
  function QPC(C: ^UInt64): LongBool; static; external 'QueryPerformanceCounter@Kernel32.dll ' + WINAPI_CC;
begin
  frequency := GetMem(SizeOf(UInt64)); // at least qword aligned
  counter   := GetMem(SizeOf(UInt64)); // ...

  if QPF(frequency) and QPC(counter) then
    Result := counter^ / frequency^ * 1000
  else
    Result := GetTickCount();

  FreeMem(frequency);
  FreeMem(counter);
end;
{$ELSE}
function PerformanceTimer(): Double;
begin
  Result := GetTickCount();
end;
{$ENDIF}


{$IFNDEF SRL_FILE_INCLUDED}        
{$DEFINE SRL_FILE_INCLUDED}


function BackupFile(filePath: String): Boolean;
var
  f: Int32;
  contents: String;
begin
  f := OpenFile(filePath, False);
  if not ReadFileString(f, contents, FileSize(f)) then
    Exit;

  CloseFile(f);
  Result := WriteFileContents(filePath + '.bak', contents, False);
end;

function RestoreFile(filePath: String): Boolean;
var
  f: Int32;
  contents: String;
begin
  f := OpenFile(filePath + '.bak', False);
  if not ReadFileString(f, contents, FileSize(f)) then
    Exit;

  CloseFile(f);
  Result := WriteFileContents(filePath, contents, False);
  DeleteFile(filePath + '.bak');
end;

function DirectoryIsEmpty(const directory: String): Boolean;
begin
  Result := (FindFiles(directory, False) = []) and (FindDirectories(directory, False) = []);
end;

function DeleteFiles(const directory: String; skip: TStringArray = []): Boolean;
  function _SkipFile(dir: String): Boolean;
  var
    s: String;
  begin
    for s in skip do
      if dir.Contains(s) then
        Exit(True);
  end;

var
  f: String;
begin
  for f in FindFiles(directory, True) do
  begin
    if _SkipFile(f) then
      Continue;

    if not DeleteFile(f) then
      Exit;
  end;

  Result := True;
end;

function DeleteSubDirectories(const directory: String; deleteRoot: Boolean; skip: TStringArray = []): Boolean;

  function _SkipDirectory(dir: String): Boolean;
  var
    s: String;
  begin
    for s in skip do
      if dir.Contains(s) then
        Exit(True);
  end;

  function _GetParent(dir: String): String;
  var
    strings: TStringArray;
  begin
    strings := dir.Explode(DirectorySeparator);
    SetLength(strings, High(strings));
    Result := strings.Merge(DirectorySeparator);
  end;

var
  directories, parents: TStringArray;
  i: Int32;
begin
  directories := FindDirectories(directory, True);

  while directories <> [] do
  begin
    for i := High(directories) downto 0 do
    begin
      if _SkipDirectory(directories[i]) then
      begin
        parents += _GetParent(directories[i]);
        Delete(directories, i, 1);
        deleteRoot := False;
        Continue;
      end;

      if not parents.Contains(directories[i]) and not DeleteDirectory(directories[i], False) then
        Exit;
      Delete(directories, i, 1);
    end;
  end;

  Result := not deleteRoot or DeleteDirectory(directory, False);
end;

function RMDir(const directory: String; deleteRoot: Boolean; skip: TStringArray = []): Boolean;
begin
  if not DeleteFiles(directory, skip) then
    Exit;

  Result := DeleteSubDirectories(directory, deleteRoot, skip);
end;

function RMDir(path: String): Boolean; overload;
begin
  Result := RMDir(path, True, []);
end;



{$IFNDEF SRL_STRING_INCLUDED}      
{$DEFINE SRL_STRING_INCLUDED}


(*
# String
String related methods
*)

const
  STR_WHITESPACE = #9#10#11#12#13#32;
  STR_NEW_LINE = #13#10;

(*
## String.Len
```pascal
function String.Len(): Int32; constref;
```
Returns the length of the string
*)
function String.Len(): Int32; constref;
begin
  Result := Length(Self);
end;

(*
## String.Pos
```pascal
function String.Pos(SubStr: String): Int32; constref;
```
Returns the position of the position of the first occurance of the substring
*)
function String.Pos(SubStr: String): Int32; constref;
begin
  Result := System.Pos(SubStr, self);
end;

(*
## String.PosR
```pascal
function String.PosR(SubStr: String): Int32; constref;
```
Returns the position of the position of the last occurance of the substring
*)
function String.PosR(SubStr: String): Int32; constref; 
var 
  list:TIntegerArray;
begin
  list := System.PosMulti(SubStr, self);
  if Length(list) > 0 then
    Result := list[high(list)]
  else
    Result := 0;
end;

(*
## String.PosEx
```pascal
function String.PosEx(SubStr: String): TIntegerArray; constref;
```
Returns the position of every occurance of the substring
*)
function String.PosEx(SubStr: String): TIntegerArray; constref;
begin
  Result := System.PosMulti(SubStr, self);
end;


(*
## String.Contains
```pascal
function String.Contains(subString: String): Boolean; constref;
```
Returns true if the substring exists on the string.
*)
function String.Contains(subString: String): Boolean; constref;
begin
  Result := Self.Pos(subString) > 0;
end;

(*
## String.ContainsAny
```pascal
function String.ContainsAny(subStrings: TStringArray): Boolean; constref;
```
Returns true if any of the substrings exists on the string.
*)
function String.ContainsAny(subStrings: TStringArray): Boolean; constref;
var
  str: String;
begin
  for str in subStrings do
    if Self.Contains(str) then
      Exit(True);
end;

(*
## String.ContainsAll
```pascal
function String.ContainsAll(subStrings: TStringArray): Boolean; constref;
```
Returns true if all of the substrings exist on the string.
*)
function String.ContainsAll(subStrings: TStringArray): Boolean; constref;
var
  str: String;
begin
  Result := True;
  for str in subStrings do
    if not Self.Contains(str) then
      Exit(False);
end;


(*
## String.Startswith
```pascal
function String.Startswith(Prefix: String): Boolean; constref;
```
Returns `True` if the string starts with the given string `Prefix`
*)
function String.StartsWith(Prefix: String): Boolean; constref;
begin
  Result := Self.Pos(Prefix) = 1;
end;

(*
## String.Endswith
```pascal
function String.Endswith(Suffix: String): Boolean; constref;
```
Returns `True` if the string ends with the given string `Suffix`
*)
function String.EndsWith(Suffix: String): Boolean; constref;
var
  i,l: Int32;
begin
  if Length(Suffix) > Length(Self) then
    Exit(False);
  Result := True;
  l := Length(Self);
  for i:=1 to Length(Suffix) do
    if (Suffix[i] <> Self[l-Length(Suffix)+i]) then
      Exit(False);
end;

(*
## String.Capitalize
```pascal
function String.Capitalize(): String; constref;
```
Returns the string with every word captalized
*)
function String.Capitalize(): String; constref;
begin
  Result := System.Capitalize(Self);
end;

(*
## String.Upper
```pascal
function String.Upper(): String; constref;
```
Returns the string with every character converted to uppercase
*)
function String.Upper(): String; constref;
begin
  Result := Uppercase(Self);
end;

(*
## String.Lower()
```pascal
function String.Lower(): String; constref;
function String.ToLower(): String; constref;
```
Returns the string with every character converted to lowercase
*)
function String.Lower(): String; constref;
begin
  Result := Lowercase(Self);
end;

function String.ToLower(): String; constref;
begin
  Result := Lowercase(Self);
end;

(*
## String.After
```pascal
function String.After(SubStr: String): String; constref;
```
Copy the string from after the first occurrence of SubStr
*)
function String.After(SubStr: String): String; constref;
var
  p: UInt32;
begin
  p := System.Pos(SubStr, Self);
  if (p = 0) then Exit(Self);
  Inc(p, Length(SubStr));
  Result := Copy(Self, p, Length(Self) - p + 1);
end;

(*
## String.Before
```pascal
function String.Before(SubStr: String): String; constref;
```
Copy the string from before the first occurrence of SubStr
*)
function String.Before(SubStr: String): String; constref;
var
  p: UInt32;
begin
  p := System.Pos(SubStr, Self);
  if (p = 0) then Exit(Self);
  Result := Copy(Self, 1, p - 1);
end;

function String.Between(start, finish: String): String; constref;
begin
  Result := System.Between(start, finish, Self);
end;



function String.SubString(start, finish: Int32): String; constref;
begin
  Result := Copy(Self, start, finish);
end;

function String.SubString(finish: Int32): String; constref; overload;
begin
  Result := Copy(Self, 1, finish);
end;


(*
## String.Count
```pascal
function String.Count(Str: String): Int32; constref;
```
Count the number of occurrences of the given string.
*)
function String.Count(Str: String): Int32;
begin
  Result := Length(Self.PosEx(Str));
end;

(*
## String.Replace
```pascal
function String.Replace(SubStr, ReplaceStr: String; Flags: TReplaceFlags=[rfReplaceAll]): String; constref;
```
Replace [all by default] occurrences of the given SubStr with with ReplaceStr
*)
function String.Replace(SubStr, ReplaceStr: String; Flags: TReplaceFlags=[rfReplaceAll]): String; constref;
begin
  Result := StringReplace(Self, SubStr, ReplaceStr, Flags);
end;

function String.ReplaceAll(SubStrReplaceStrArray: array of TStringArray; Flags: TReplaceFlags=[rfReplaceAll]): String; constref;
var
  i: Int32;
begin
  Result := Self;
  for i := 0 to High(SubStrReplaceStrArray) do
  begin
    if Length(SubStrReplaceStrArray[i]) <> 2 then
      raise 'SubStrReplaceStrArray children should have only 2 elements, a SubStr and a ReplaceStr.';

    Result := StringReplace(Result, SubStrReplaceStrArray[i,0], SubStrReplaceStrArray[i,1], Flags);
  end;
end;


(*
## String.Split
```pascal
function String.Split(delimiter: String): TStringArray; constref;
```
Split up the string at each delimiter into smaller strings
*)
function String.Split(delimiter: String): TStringArray; constref;
begin
  Result := System.Explode(delimiter, Self);
end;

function String.Explode(Delimiter: String): TStringArray; constref;
begin
  Result := System.Explode(Delimiter, Self);
end;

(*
## String.Trim
```pascal
function String.Trim(chars:String = STR_WHITESPACE): String; constref;
function String.Strip(chars:String = STR_WHITESPACE): String; constref;
```
Return a copy of the string with leading and trailing characters removed.
*)
function String.Trim(chars:String = STR_WHITESPACE): String; constref;
var Lo,Hi: UInt32 = 1;
begin
  Hi:=Length(Self);
  while (Lo <= Hi) and (System.Pos(Self[Lo],Chars) <> 0) do Inc(Lo);
  while (Hi >= 1)  and (System.Pos(Self[Hi],Chars) <> 0) do Dec(Hi);
  Result := Copy(Self, Lo, Hi-Lo+1);
end;

function String.Strip(chars:String = STR_WHITESPACE): String; constref;
var Lo,Hi: UInt32 = 1;
begin
  Hi:=Length(Self);
  while (Lo <= Hi) and (System.Pos(Self[Lo],Chars) <> 0) do Inc(Lo);
  while (Hi >= 1)  and (System.Pos(Self[Hi],Chars) <> 0) do Dec(Hi);
  Result := Copy(Self, Lo, Hi-Lo+1);
end;


{*
## String.StripL
```pascal
function String.StripL(Chars:String = STR_WHITESPACE): String; constref;
```
Return a copy of the string with leading characters removed.
*}
function String.StripL(Chars:String = STR_WHITESPACE): String; constref;
var Lo,Hi: UInt32 = 1;
begin
  Hi:=Length(Self);
  while (Lo <= Hi) and (System.Pos(Self[Lo],Chars) <> 0) do Inc(Lo);
  Result := Copy(Self, Lo, Hi-Lo+1);
end;  


{*
## String.StripR
```pascal
function String.StripR(Chars:String = STR_WHITESPACE): String; constref;
```
Return a copy of the string with trailing characters removed.
*}
function String.StripR(Chars:String = STR_WHITESPACE): String; constref;
var Lo,Hi: UInt32 = 1;
begin
  Hi:=Length(Self);
  while (Hi >= 1) and (System.Pos(Self[Hi],Chars) <> 0) do Dec(Hi);
  Result := Copy(Self, Lo, Hi-Lo+1);
end; 

(*
## String.IsAlphaNum
```pascal
function String.IsAlphaNum(): Boolean; constref;
```
Test if a string only contains alpha numerical characters.
*)
function String.IsAlphaNum(): Boolean; constref;
var ptr: PChar; hiptr:PtrUInt;
begin
  if Length(Self) = 0 then Exit(False);
  ptr := PChar(Self);
  hiptr := PtrUInt(PtrUInt(ptr) + Length(self));
  while PtrUInt(ptr) < hiptr do
    if not (ptr^ in ['0'..'9','a'..'z','A'..'Z']) then
      Exit(False)
    else
      Inc(ptr);
  Result := True;
end;

function Char.IsAlphaNum(): Boolean; constref;
begin
  Result := (Self in ['A'..'Z', 'a'..'z','0'..'9']);
end;

(*
## String.IsDigit
```pascal
function String.IsDigit(): Boolean; constref;
```
Test if a sting is a digit
*)
function String.IsDigit(): Boolean; constref;
var 
  ptr: PChar;
  hiptr:PtrUInt;
begin
  if Length(Self) = 0 then Exit(False);
  ptr := PChar(Self);
  hiptr := PtrUInt(PtrUInt(ptr) + Length(self));
  while PtrUInt(ptr) < hiptr do
    if not (ptr^ in ['0'..'9']) then
      Exit(False)
    else
      Inc(ptr);
  Result := True;
end;

function Char.IsDigit(): Boolean; constref;
begin
  Result := (Self in ['0'..'9']);
end;

(*
## String.IsFloat
```pascal
function String.IsFloat(): Boolean; constref;
```
Test if a string is a floating point number
*)
function String.IsFloat(): Boolean; constref;
var 
  ptr: PChar; 
  hiptr:PtrUInt; 
  i:Int32; 
  dotAdded:Boolean;
begin
  if Length(Self) = 0 then Exit(False);
  ptr := PChar(Self);
  i:=0;
  hiptr := PtrUInt(PtrUInt(ptr) + Length(self));
  while PtrUInt(ptr) < hiptr do
    if not (ptr^ in ['0'..'9']) then
      if (i >= 1) and (ptr^ = '.') and not(dotAdded) then
      begin
        Inc(ptr);
        inc(i);
        dotAdded:=True;
      end else
        Exit(False)
    else begin
      Inc(ptr);
      inc(i);
    end;
  Result := True;
end;

function Char.IsFloat(): Boolean; constref;
begin
  Result := String(Self).IsFloat();
end;

(*
## String.IsAlpha
```pascal
function String.IsAlpha(): Boolean; constref;
```
Test if a string only contains letters a-zA-Z
*)
function String.IsAlpha(): Boolean; constref;
var 
  ptr: PChar; 
  hiptr:PtrUInt;
begin
  if Length(Self) = 0 then Exit(False);
  ptr := PChar(Self);
  hiptr := PtrUInt(PtrUInt(ptr) + Length(self));
  while PtrUInt(ptr) < hiptr do
    if not (ptr^ in ['A'..'Z', 'a'..'z']) then
      Exit(False)
    else
      Inc(ptr);
  Result := True;
end;

function Char.IsAlpha(): Boolean;
begin
  Result := (Self in ['A'..'Z', 'a'..'z']);
end;

function String.ExtractNumber(DefaultValue: Int64 = -1): Int64; constref;
begin
  Result := StrToIntDef(ExtractFromStr(Self, Numbers), DefaultValue);
end;

function String.ExtractInteger(DefaultValue: Int64 = -1): Int64; constref;
begin
  Result := StrToIntDef(ExtractFromStr(Self, Numbers), DefaultValue);
end;

(*
## String.ExtractNumbers
```pascal
function String.ExtractNumbers(): TExtendedArray; constref;
```
Extract all the numbers found in the string, as there could be floating point numbers 
as well it reutnrs a TExtendedArray.
*)
function String.ExtractNumbers(): TExtendedArray; constref;
var
  i,c,l:Int32;
  Tmp: TStringArray;
begin
  L := Length(Self);
  for i:=1 to Length(Self) do
  begin
    if Self[i].IsDigit() then
    begin
      Tmp += Self[i];
      while (Inc(i) <= L) and (Self[i].IsDigit()) do Tmp[c] += Self[i];
      if (i <= L) and (Self[i] = '.') then
      begin
        Tmp[c] += Self[i];
        while (Inc(i) <= L) and (Self[i].IsDigit()) do Tmp[c] += Self[i];
      end;
      if (i > L) then Break;
      Inc(c);
    end;
  end;

  SetLength(Result, Length(tmp));
  for i:=0 to High(Tmp) do
    Result[i] := StrToFloat(Tmp[i]);
end;

(*
## String.ExtractNumbersEx
```pascal
function String.ExtractNumbersEx(): TExtendedArray; constref;
```
Extract all the numbers found in the string, this time every number 
ends up in each their index. For example ``'1234'`` would return ``[1,2,3,4]``
*)
function String.ExtractNumbersEx(): TExtendedArray; constref;
var
  i, c: Int32;
begin
  SetLength(Result, 0);
  c := 0;

  for i := 1 to High(Self) do
    if (Self[i] in ['0'..'9']) then
    begin
      SetLength(Result, c + 1);
      Result[c] := StrToInt(Self[i]);
      Inc(c);
    end;
end;

(*
## String.FileExt
```pascal
function String.FileExt(): String; constref;
```
Returns the file extension
*)
function String.FileExt(): String; constref;
begin
  Result := ExtractFileExt(Self);
  Delete(Result,1,1);
end;

(*
## String.FileName
```pascal
function String.FileName(): String; constref;
```
Returns the file name
*)
function String.FileName(): String; constref;
begin
  if Length(Self) <> 0 then
    Result := Self.Explode('.')[0];
end;

(*
## String.Hex
```pascal
function String.Hex(): string; constref;
```
Returns the hexadecimal value that represents the string.
*)
function String.Hex(): string; constref;
var
  n: Int32;
begin
  Result := '';
  for n := 1 to Length(Self) do
    Result := LowerCase(Result + IntToHex(Ord(Self[n]), 2));
end;

function String.Hash(): UInt32; constref;
var
  i: Int32;
begin
  Result := $811C9DC5;
  for i := 1 to Length(Self) do
    Result := (Result * $1000193) xor Ord(Self[i]);
end;

//---| operator overloads bellow this |---------------------------------------\\
(*
## operator string * int32
```pascal
operator * (left:String; Right:Int32): String;
```
Replicates the string the given amount of times. So ``'ho!' * 3`` would generate ``ho!ho!ho!``
*)
operator * (left: String; Right: Int32): String;
var
  i,H: Int32;
begin
  if Length(left) = 0 then 
    Exit('');
  Result := left;
  H := Length(left);
  SetLength(Result, H*Right);
  for i:=1 to Right-1 do
    MemMove(left[1], Result[1+H*i], H);
end;

operator * (left:Char; Right:Int32): String;
begin
  Result := String(Left) * Right;
end;

(*
## operator string in string
```pascal
operator in (left:String; Right:String): Boolean;
```
Returns ``True`` if the string exists in the other string. So ``'hell' in 'hello world'`` would be ``True`` 
*)
operator in (left:Char; Right:String): Boolean;
begin
  Result := System.Pos(left, Right) > 0;
end;

operator in (left:String; Right:String): Boolean;
begin
  Result := System.Pos(left, Right) > 0;
end;

operator in (Right: TStringArray; Left: String): Boolean;
var
  i: Int32;
begin
  for i := 0 to High(Right) do
    if System.Pos(Right[i], Left) > 0 then
      Exit(True);
end;


{$IFNDEF SRL_STRINGARRAY_INCLUDED} 
{$DEFINE SRL_STRINGARRAY_INCLUDED}


procedure TStringArray.Append(const value: String);
var
  top:Int32;
begin
  top := Length(Self);
  SetLength(self, top+1);
  Self[top] := value;
end;

procedure TStringArray.Insert(const value: String; index: Int32);
var
  l: UInt32;
begin
  l := Length(Self);
  if (l <= index) then
  begin
    Self.Append(value);
    Exit;
  end;

  SetLength(Self, l + 1);
  MemMove(Self[index], self[index + 1], (L - index) * SizeOf(Self[0]));
  Self[index] := value;
end;

procedure TStringArray.Del(const index: Int32; const count: Int32 = 1);
begin
  Delete(Self, index, count);
end;


function TStringArray.Len(): Int32;
begin
  Result := Length(Self);
end;

procedure TStringArray.Remove(const value: String; const All: Boolean = False);
var
  i: Int32;
  lst: TIntegerArray;
begin
  if (not All) then
  begin
    i := Self.Find(value);
    if i >= 0 then Self.Del(i);
    Exit;
  end;

  lst := Self.FindAll(value);
  for i:=High(lst) downto 0 do
    Self.Del(lst[i]);
end;

function TStringArray.Pop(): String;
var
  h: Int32;
begin
  h := High(Self);
  Result := Self[h];
  SetLength(Self, h);
end;

procedure TStringArray.Extend(const arr: TStringArray);
var
  i, len: Int32;
begin
  len := Length(Self);
  SetLength(Self, len+Length(arr));
  for i:=0 to High(arr) do
    Self[len+i] := arr[i];
end;


function TStringArray.Find(const value: String): Int32; constref;
begin
  for Result := 0 to High(Self) do
    if value = Self[Result] then
      Exit;
  Result := -1;
end;

function TStringArray.FindAll(const value: String): TIntegerArray; constref;
var
  i: UInt32;
begin
  for i:=0 to High(Self) do
    if (Self[i] = value) then
      Result += i;
end;


function TStringArray.Contains(const value: String): Boolean; constref;
begin
  Result := Self.Find(value) > -1;
end;

function TStringArray.ContainsAny(const values: TStringArray): Boolean; constref;
var
  value: String;
begin
  for value in values do
    if Self.Contains(value) then
      Exit(True);
end;

function TStringArray.ContainsAll(const values: TStringArray): Boolean; constref;
var
  value: String;
begin
  for value in values do
    if not Self.Contains(value) then
      Exit;
  Result := True;
end;


procedure TStringArray.Sort();
begin
  System.Sort(Self);
end;

function TStringArray.Sorted(): TStringArray;
begin
  Result := Copy(Self);
  System.Sort(Result);
end;


procedure TStringArray.WeightedSort(weights: TIntegerArray; iLo, iHi: Int32; sortUp: Boolean);
var
  lo, hi, mid: Int32;
begin
  if (Length(weights) <> Length(Self)) then Exit;
  lo := iLo;
  hi := iHi;
  mid := weights[(lo + hi) shr 1];
  repeat
    if sortUp then
    begin
      while (weights[lo] < mid) do Inc(lo);
      while (weights[hi] > mid) do Dec(hi);
    end
    else
    begin
      while (weights[lo] > mid) do Inc(lo);
      while (weights[hi] < mid) do Dec(hi);
    end;

    if (lo <= hi) then
    begin
      Swap(weights[lo], weights[hi]);
      Swap(Self[lo], Self[hi]);
      Inc(lo);
      Dec(hi);
    end;
  until lo > hi;

  if (hi > iLo) then Self.WeightedSort(weights, iLo, hi, sortUp);
  if (lo < iHi) then Self.WeightedSort(weights, lo, iHi, sortUp);
end;

function TStringArray.WeightSorted(weights: TIntegerArray; iLo, iHi: Int32; sortUp: Boolean): TStringArray; constref;
begin
  Result := Copy(Self);
  Result.WeightedSort(weights, iLo, iHi, sortUp);
end;


function TStringArray.Reversed(): TStringArray;
var
  lo:PtrUInt;
  p,r:^String;
begin

  SetLength(Result, Length(Self));
  p := @Self[High(Self)];
  r := @Result[0];

  lo := PtrUInt(@Self[0]);
  while (lo<=PtrUInt(p)) do
  begin
    r^ := p^;
    dec(p);
    inc(r);
  end;
end;

procedure TStringArray.Reverse();
var
  tmp:String;
  lo,hi:^String;
begin
  if (Length(Self) = 0) then Exit;

  lo := @Self[0];
  hi := @Self[High(self)];
  while (PtrUInt(lo)<PtrUInt(hi)) do
  begin
    tmp := hi^;
    hi^ := lo^;
    lo^ := tmp;
    dec(hi);
    inc(lo);
  end;
end;


function TStringArray.Combine(const Arr2: TStringArray): TStringArray; constref;
var
  i,j: Int32;
begin
  if (Length(Arr2) = 0) then
    Exit(Copy(Self));

  Result := Self;
  SetLength(Result, Length(Self) + Length(Arr2));

  j := 0;
  for i := Length(Self) to High(Arr2) + Length(Self) do
  begin
    Result[i] := Arr2[j];
    Inc(j);
  end;
end;

function TStringArray.Equals(other:TStringArray): Boolean; constref;
var
  i:Int32;
begin
  if (Length(Self) <> Length(Other)) then Exit(False);
  if (Length(Self) = 0) then Exit(True);

  for i:=0 to High(self) do
    if (self[i] <> Other[i]) then
      Exit(False);
  Result := True;
end;

function TStringArray.Merge(glue: String = ''): String; constref;
var
  i: Int32;
begin
  if Length(Self) = 0 then Exit;

  Result := Self[0];
  for i := 1 to High(Self) do
    Result += glue + Self[i];
end;


procedure TStringArray.ClearDuplicates();
var
  i: Int32;
  unique: TStringArray;
begin
  for i := 0 to High(Self) do
    if unique.Find(Self[i]) = -1 then
      unique += Self[i];

  Self := unique;
end;

function TStringArray.Unique(): TStringArray;
begin
  Result := Copy(Self);
  Result.ClearDuplicates();
end;


function TStringArray.ToLower(): TStringArray;
var
  i: Int32;
begin
  for i := 0 to High(Self) do
    Result += LowerCase(Self[i]);
end;

function TStringArray.ToUpper(): TStringArray;
var
  i: Int32;
begin
  for i := 0 to High(Self) do
    Result += UpperCase(Self[i]);
end;


function TStringArray.Replace(const oldvalue, newvalue: String): TStringArray;
var
  i: Int32;
begin
  for i := 0 to High(Self) do
    Result += StringReplace(Self[i], oldvalue, newvalue, [rfReplaceAll]);
end;


function TStringArray.CountSubstring(const subStr: String): Int32;
var
  i: Int32;
begin
  for i := 0 to High(Self) do
    if Self[i].Contains(subStr) then
      Inc(Result);
end;

function TStringArray.Count(const value: String): Int32;
var
  i: Int32;
begin
  for i := 0 to High(Self) do
    if Self[i] = value then
      Inc(Result);
end;


function TStringArray.Intersection(other: TStringArray): TStringArray; constref;
var
  i: Int32;
begin
  for i := 0 to High(other) do
    if Self.Find(other[i]) > -1 then
      Result += other[i];
end;

function TStringArray.Difference(other: TStringArray): TStringArray; constref;
var
  item: String;
begin
  for item in Self do
    if other.Find(item) = -1 then
      Result += item;
  Result.ClearDuplicates();
end;

function TStringArray.SymmetricDifference(other: TStringArray): TStringArray; constref;
var
  item: String;
begin
  for item in Self do
    if other.Find(item) = -1 then
      Result += item;

  for item in other do
    if Self.Find(item) = -1 then
      Result += item;

  Result.ClearDuplicates();
end;



function TStringArray.RandomValue(): String; constref;
begin
  if Self <> [] then
    Result := Self[System.Random(Low(Self), High(Self))];
end;


{$IFNDEF WL_STRING_INCLUDED}       
{$DEFINE WL_STRING_INCLUDED}


//by Flight
function String.Replicate(count: Integer; separator: String = ''): String;
var
  i: Int32;
begin
 Result := Self;

 for i := 1 to count do
   Result += separator + Self;
end;


(*
## String.Case
```pascal
function String.CamelCase(): String; constref;
function String.SnakeCase(): String; constref;
function String.UpperSnakeCase(): String; constref;
function String.KebabCase(): String; constref;
function String.PascalCase(): String; constref;
function String.SentenceCase(): String; constref;
function String.TitleCase(): String; constref;
```
Returns the string with different forms of capitalization.

Example
```pascal
var
  str: String = 'HELLO WORLD';
begin
  WriteLn str.TitleCase(); //Prints 'Hello World'
end;
```
*)
function String.CamelCase(): String; constref;
var
  i, len: Int32;
begin
  for i := 1 to len := Length(Self) do
  begin
    if (Self[i] <> ' ') then
    begin
      Result += LowerCase(Self[i]);
      Continue;
    end;

    if (Inc(i) <= len) then
      Result += UpCase(Self[i]);
  end;
end;

function String.SnakeCase(): String; constref;
var
  i, len: Int32;
begin
  for i := 1 to len := Length(Self) do
  begin
    if (Self[i] <> ' ') then
    begin
      Result += LowerCase(Self[i]);
      Continue;
    end;

    Result += '_';
  end;
end;

function String.UpperSnakeCase(): String; constref;
var
  i, len: Int32;
begin
  for i := 1 to len := Length(Self) do
  begin
    if (Self[i] <> ' ') then
    begin
      Result += UpCase(Self[i]);
      Continue;
    end;

    Result += '_';
  end;
end;

function String.KebabCase(): String; constref;
var
  i, len: Int32;
begin
  for i := 1 to len := Length(Self) do
  begin
    if (Self[i] <> ' ') then
    begin
      Result += LowerCase(Self[i]);
      Continue;
    end;

    Result += '-';
  end;
end;

function String.PascalCase(): String; constref;
var
  i, len: Int32;
begin
  if Length(Self) = 0 then
    Exit;
  Result += UpCase(Self[1]);
  for i := 2 to len := Length(Self) do
  begin
    if (Self[i] <> ' ') then
    begin
      Result += LowerCase(Self[i]);
      Continue;
    end;

    if (Inc(i) <= len) then
      Result += UpCase(Self[i]);
  end;
end;

function String.SentenceCase(): String; constref;
begin
  if Length(Self) = 0 then Exit;
  Result := LowerCase(Self);
  Result[1] := UpCase(Result[1]);
end;

function String.TitleCase(): String; constref;
var
  i, len: Int32;
begin
  if Length(Self) = 0 then
    Exit;

  Result += UpCase(Self[1]);

  for i := 2 to len := Length(Self) do
  begin
    if (Self[i] <> ' ') then
    begin
      Result += LowerCase(Self[i]);
      Continue;
    end;

    Result += ' ';
    if (Inc(i) <= len) then
      Result += UpCase(Self[i]);
  end;
end;


(*
## String.Is
```pascal
function String.IsURL(): Boolean;
function String.IsEmail(): Boolean;
function String.IsUUID(): Boolean;
function String.IsUUIDV4(): Boolean;
function String.IsRefreshToken(): Boolean;
```
Checks if a string is a certain "thing" with some predefined regex patterns.
*)
function String.IsURL(): Boolean;
const
  REGEX: String = '^https?:\/\/(?:www\.)?[-a-zA-Z0-9@:%._\+~#=]{1,256}\.[a-zA-Z0-9()]{1,6}\b(?:[-a-zA-Z0-9()@:%_\+.~#?&\/=]*)$';
begin
  Result := ExecRegExpr(REGEX, System.Trim(Self));
end;

function String.IsEmail(): Boolean;
const
  REGEX: String = '^[\w-\.]+@([\w-]+\.)+[\w-]{2,4}$';
begin
  Result := ExecRegExpr(REGEX, System.Trim(Self));
end;

function String.IsTime(): Boolean;
const
  REGEX = '(?:[01]\d|2[0-3])([:.\-_\ \''])?(?:[0-5]\d)([:.\-_\ \''])?(?:[0-5]\d)';
begin
  Result := ExecRegExpr(REGEX, System.Trim(Self));
end;

function String.IsUUID(): Boolean;
const
  REGEX: String = '[0-9a-fA-F]{32}|[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}';
begin
  Result := ExecRegExpr(REGEX, System.Trim(Self));
end;

function String.IsUUIDV4(): Boolean;
const
  REGEX: String = '[0-9a-fA-F]{32}|[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}';
var
  tmp: String;
begin
  tmp := System.Trim(Self);

  case Length(tmp) of
    36: if Self[15] <> '4' then Exit;
    32: if Self[13] <> '4' then Exit;
    else Exit;
  end;

  Result := ExecRegExpr(REGEX, tmp);
end;

function String.IsRefreshToken(): Boolean;
const
  REGEX = '[0-9A-Za-z-_]{22}';
begin
  Result := ExecRegExpr(REGEX, System.Trim(Self));
end;


{$IFNDEF WS_UTILS_INCLUDED}        
(*
Utility methods
*)

{$DEFINE WS_UTILS_INCLUDED}


procedure TerminateScript(reason: String); overload;
begin
  WriteLn('Terminating: ' + reason);
  TerminateScript();
end;

procedure DebugLn(name, text: String);
begin
  WriteLn(SRL.TimeStamp() + ':[' + name + ']: ' + text);
end;

function TJSONArray.High(): Int32;
begin
  if Self = nil then
    Exit(-1);
  Result := Self.length()-1;
end;

{$IFDEF WINDOWS}
function ShowWindow(hwnd: TOSWindow; nCmdShow: UInt32): LongBool;
external 'ShowWindow@user32.dll ' + WINAPI_CC;

function SetWindowAttribute(hwnd: TOSWindow; dwAttribute: DWORD; pvAttribute: Pointer; cbAttribute: DWORD): UInt32;
external 'DwmSetWindowAttribute@dwmapi.dll ' + WINAPI_CC;

function SetWindowDarkTitleBar(hwnd: TOSWindow): UInt32;
const
  DWMWA_USE_IMMERSIVE_DARK_MODE: Integer = 20;
  DARK: LongBool = True;
begin
  Result := SetWindowAttribute(hwnd, DWMWA_USE_IMMERSIVE_DARK_MODE, @DARK, SizeOf(DARK));
end;

type PWideChar = ^WideChar;

function SetWindowTheme(hwnd: TOSWindow; pszSubAppName: PWideChar; pszSubIdList: PWideChar): UInt32;
external 'SetWindowTheme@uxtheme.dll ' + WINAPI_CC;

function SetWindowTheme(hwnd: TOSWindow; pszSubAppName: WideString; pszSubIdList: PWideChar = nil): UInt32; overload;
begin
  Result := SetWindowTheme(hwnd, PWideChar(pszSubAppName), pszSubIdList);
end;

function GetProcAddr(handle: PtrUInt; name: PChar): Pointer;
external 'GetProcAddress@kernel32.dll '+ WINAPI_CC;

type
{$SCOPEDENUMS ON}
  TPreferredAppMode = (Default, AllowDark, ForceDark, ForceLight, Max);
{$SCOPEDENUMS OFF}

var
  ShouldAppUseDarkMode: function(): LongBool;
  AllowDarkModeForWindow: function(hWnd: TOSWindow; allow: LongBool): LongBool;
  AllowDarkModeForApp: function(allow: LongBool): LongBool;
  SetPreferredAppMode: function(appMode: TPreferredAppMode): TPreferredAppMode;
  FlushMenuThemes: procedure();
  RefreshImmersiveColorPolicyState: procedure();
{$ENDIF}


{$IFNDEF WS_ASYNC_INCLUDED}        
{$DEFINE WS_ASYNC_INCLUDED}


type
  EMonitorState = (NONE, DOWNLOAD, UNZIP, CLEAN);

  TMonitor = record
    Package: String;
    CurrentFile: String;
    State: EMonitorState;
    IsSetup: Boolean;

    Caption: TLabel;
    Button: TButton;
    Timer: TTimer;
  end;

  TWaspAsync = record
    Path: String;
  end;

procedure TWaspAsync.Write(name, content: String);
begin
  if not WriteFileContents(Self.Path + name, content, False) then
    TerminateScript('WaspAsync: Failed to write async file: ' + name);
end;

procedure TWaspAsync.Run(name: String; params: TStringArray);
begin
  if not name.EndsWith('.simba') then
    name += '.simba';
  RunScript(Self.Path + name, params);
end;


function TWaspAsync.GetDownloaderContent(): String;
begin
  Result += "var" + LineEnding;
  Result += "  timeout: TTimer;" + LineEnding;
  Result += "  http: Int32;" + LineEnding;
  Result += "  url, pkg: String;" + LineEnding;
  Result += "  t: UInt64;" + LineEnding + LineEnding;
  Result += "procedure OnTimer({$H-}sender: TObject);{$H+}" + LineEnding;
  Result += "begin" + LineEnding;
  Result += "  WriteLn('[AsyncDownloader]: Downloading ', pkg, '...');" + LineEnding + LineEnding;
  Result += "  if GetTickCount() > t then" + LineEnding;
  Result += "  begin" + LineEnding;
  Result += "    WriteLn('[AsyncDownloader]: If this has taken over 5 minutes please restart Simba.');" + LineEnding;
  Result += "    WriteLn('[AsyncDownloader]: If you are rate limited you need to wait 1 hour.');" + LineEnding;
  Result += "    t := GetTickCount() + 120000;" + LineEnding;
  Result += "  end;" + LineEnding;
  Result += "end;" + LineEnding + LineEnding;
  Result += "procedure Free();" + LineEnding;
  Result += "begin" + LineEnding;
  Result += "  timeout.setEnabled(False);" + LineEnding;
  Result += "  timeout.Free();" + LineEnding;
  Result += "  FreeHTTPClient(http);" + LineEnding;
  Result += "  CloseFile(CreateFile({$MACRO CURRENT_DIRECTORY} + 'downloader-' + LowerCase(pkg) + '.done'));" + LineEnding;
  Result += "end;" + LineEnding + LineEnding;
  Result += "procedure RunTimer();" + LineEnding;
  Result += "begin" + LineEnding;
  Result += "  timeout.setOnTimer(@OnTimer);" + LineEnding;
  Result += "  timeout.setEnabled(True);" + LineEnding;
  Result += "end;" + LineEnding + LineEnding;
  Result += "begin" + LineEnding;
  Result += "  url := GetProcessParameter('url');" + LineEnding;
  Result += "  pkg := GetProcessParameter('pkg');" + LineEnding + LineEnding;
  Result += "  if FileExists({$MACRO CURRENT_DIRECTORY} + 'downloader-' + LowerCase(pkg) + '.done') then" + LineEnding;
  Result += "    DeleteFile({$MACRO CURRENT_DIRECTORY} + 'downloader-' + LowerCase(pkg) + '.done');" + LineEnding + LineEnding;
  Result += "  timeout.Init(nil);" + LineEnding;
  Result += "  timeout.SetName('downloader_timeout');" + LineEnding;
  Result += "  timeout.SetInterval(20000);" + LineEnding;
  Result += "  http := InitializeHTTPClient(True);" + LineEnding;
  Result += "  Sync(@RunTimer);" + LineEnding;
  Result += "  AddOnTerminate(@Free);" + LineEnding + LineEnding;
  Result += "  WriteLn('[AsyncDownloader]: Downloading ', pkg, ', this might take a while.');" + LineEnding;
  Result += "  t := GetTickCount() + 120000;" + LineEnding + LineEnding;
  Result += "  try" + LineEnding;
  Result += "    if GetHTTPPageEx(http, url, GetProcessParameter('destination')) = 200 then" + LineEnding;
  Result += "      WriteLn('[AsyncDownloader]: ' + pkg + ' downloaded.')" + LineEnding;
  Result += "    else" + LineEnding;
  Result += "      WriteLn('[AsyncDownloader]: Failed to download: ' + url);" + LineEnding;
  Result += "  except" + LineEnding;
  Result += "    WriteLn('[AsyncDownloader]: Error: ', GetExceptionMessage());" + LineEnding;
  Result += "  end;" + LineEnding;
  Result += "end;" + LineEnding;
end;

function TWaspAsync.GetUnzipperContent(): String;
begin
  Result += "var" + LineEnding;
  Result += "  path, name: String;" + LineEnding + LineEnding;
  Result += "procedure Free();" + LineEnding;
  Result += "begin" + LineEnding;
  Result += "  CloseFile(CreateFile({$MACRO CURRENT_DIRECTORY} + 'unzipper-' + LowerCase(name) + '.done'));" + LineEnding;
  Result += "end;" + LineEnding + LineEnding;
  Result += "begin" + LineEnding;
  Result += "  path := GetProcessParameter('path');" + LineEnding;
  Result += "  name := GetProcessParameter('name');" + LineEnding + LineEnding;
  Result += "  if FileExists({$MACRO CURRENT_DIRECTORY} + 'downloader-' + LowerCase(name) + '.done') then" + LineEnding;
  Result += "    DeleteFile({$MACRO CURRENT_DIRECTORY} + 'downloader-' + LowerCase(name) + '.done');" + LineEnding + LineEnding;
  Result += "  AddOnTerminate(@Free);" + LineEnding + LineEnding;
  Result += "  WriteLn('[AsyncUnzipper]: Unzipping ', name, ', this might take a while.');" + LineEnding + LineEnding;
  Result += "  try" + LineEnding;
  Result += "    UnZipFile(path + name + '.zip', path + name);" + LineEnding;
  Result += "    DeleteFile(path + name + '.zip');" + LineEnding;
  Result += "  except" + LineEnding;
  Result += "    WriteLn('[AsyncUnzipper]: Error: ', GetExceptionMessage());" + LineEnding;
  Result += "  end;" + LineEnding;
  Result += "end;" + LineEnding;
end;

function TWaspAsync.GetMoverContent(): String;
begin
  Result += "const" + LineEnding;
  Result += "  SEP = DirectorySeparator;" + LineEnding + LineEnding;
  Result += "procedure TerminateScript(reason: String); overload;" + LineEnding;
  Result += "begin" + LineEnding;
  Result += "  WriteLn('[AsyncMover]: Terminating: ' + reason);" + LineEnding;
  Result += "  TerminateScript();" + LineEnding;
  Result += "end;" + LineEnding + LineEnding + LineEnding;
  Result += "function TStringArray.Find(const value: String): Integer; constref;" + LineEnding;
  Result += "begin" + LineEnding;
  Result += "  for Result := 0 to High(Self) do" + LineEnding;
  Result += "    if value = Self[Result] then" + LineEnding;
  Result += "      Exit;" + LineEnding;
  Result += "  Result := -1;" + LineEnding;
  Result += "end;" + LineEnding + LineEnding;
  Result += "function TStringArray.Contains(const value: String): Boolean; constref;" + LineEnding;
  Result += "begin" + LineEnding;
  Result += "  Result := Self.Find(value) > -1;" + LineEnding;
  Result += "end;" + LineEnding + LineEnding;
  Result += "function TStringArray.Merge(glue:String=''): String; constref;" + LineEnding;
  Result += "var" + LineEnding;
  Result += "  i:Int32;" + LineEnding;
  Result += "begin" + LineEnding;
  Result += "  if Length(Self) = 0 then" + LineEnding;
  Result += "    Exit();" + LineEnding + LineEnding;
  Result += "  Result := Self[0];" + LineEnding;
  Result += "  for i:=1 to High(Self) do" + LineEnding;
  Result += "    Result += glue + Self[i];" + LineEnding;
  Result += "end;" + LineEnding + LineEnding;
  Result += "function BackupFile(filePath: String): Boolean;" + LineEnding;
  Result += "var" + LineEnding;
  Result += "  f: Int32;" + LineEnding;
  Result += "  contents: String;" + LineEnding;
  Result += "begin" + LineEnding;
  Result += "  f := OpenFile(filePath, False);" + LineEnding;
  Result += "  if not ReadFileString(f, contents, FileSize(f)) then" + LineEnding;
  Result += "    Exit;" + LineEnding + LineEnding;
  Result += "  CloseFile(f);" + LineEnding;
  Result += "  Result := WriteFileContents(filePath + '.bak', contents, False);" + LineEnding;
  Result += "end;" + LineEnding + LineEnding;
  Result += "function RestoreFile(filePath: String): Boolean;" + LineEnding;
  Result += "var" + LineEnding;
  Result += "  f: Int32;" + LineEnding;
  Result += "  contents: String;" + LineEnding;
  Result += "begin" + LineEnding;
  Result += "  f := OpenFile(filePath + '.bak', False);" + LineEnding;
  Result += "  if not ReadFileString(f, contents, FileSize(f)) then" + LineEnding;
  Result += "    Exit;" + LineEnding + LineEnding;
  Result += "  CloseFile(f);" + LineEnding;
  Result += "  Result := WriteFileContents(filePath, contents, False);" + LineEnding;
  Result += "  DeleteFile(filePath + '.bak');" + LineEnding;
  Result += "end;" + LineEnding + LineEnding;
  Result += "function DirectoryIsEmpty(const directory: String): Boolean;" + LineEnding;
  Result += "begin" + LineEnding;
  Result += "  Result := (FindFiles(directory, False) = []) and (FindDirectories(directory, False) = []);" + LineEnding;
  Result += "end;" + LineEnding + LineEnding;
  Result += "function DeleteFiles(const directory: String; skip: TStringArray = []): Boolean;" + LineEnding;
  Result += "  function _SkipFile(dir: String): Boolean;" + LineEnding;
  Result += "  var" + LineEnding;
  Result += "    s: String;" + LineEnding;
  Result += "  begin" + LineEnding;
  Result += "    for s in skip do" + LineEnding;
  Result += "      if Pos(s, dir) > 0 then" + LineEnding;
  Result += "        Exit(True);" + LineEnding;
  Result += "  end;" + LineEnding + LineEnding;
  Result += "var" + LineEnding;
  Result += "  f: String;" + LineEnding;
  Result += "begin" + LineEnding;
  Result += "  for f in FindFiles(directory, True) do" + LineEnding;
  Result += "  begin" + LineEnding;
  Result += "    if _SkipFile(f) then" + LineEnding;
  Result += "      Continue;" + LineEnding + LineEnding;
  Result += "    if not DeleteFile(f) then" + LineEnding;
  Result += "      Exit;" + LineEnding;
  Result += "  end;" + LineEnding + LineEnding;
  Result += "  Result := True;" + LineEnding;
  Result += "end;" + LineEnding + LineEnding;
  Result += "function DeleteSubDirectories(const directory: String; deleteRoot: Boolean; skip: TStringArray = []): Boolean;" + LineEnding + LineEnding;
  Result += "  function _SkipDirectory(dir: String): Boolean;" + LineEnding;
  Result += "  var" + LineEnding;
  Result += "    s: String;" + LineEnding;
  Result += "  begin" + LineEnding;
  Result += "    for s in skip do" + LineEnding;
  Result += "      if Pos(s, dir) > 0 then" + LineEnding;
  Result += "        Exit(True);" + LineEnding;
  Result += "  end;" + LineEnding + LineEnding;
  Result += "  function _GetParent(dir: String): String;" + LineEnding;
  Result += "  var" + LineEnding;
  Result += "    strings: TStringArray;" + LineEnding;
  Result += "  begin" + LineEnding;
  Result += "    strings := Explode(DirectorySeparator, dir);" + LineEnding;
  Result += "    SetLength(strings, High(strings));" + LineEnding;
  Result += "    Result := strings.Merge(DirectorySeparator);" + LineEnding;
  Result += "  end;" + LineEnding + LineEnding;
  Result += "var" + LineEnding;
  Result += "  directories, parents: TStringArray;" + LineEnding;
  Result += "  i: Int32;" + LineEnding;
  Result += "begin" + LineEnding;
  Result += "  directories := FindDirectories(directory, True);" + LineEnding + LineEnding;
  Result += "  while directories <> [] do" + LineEnding;
  Result += "  begin" + LineEnding;
  Result += "    for i := High(directories) downto 0 do" + LineEnding;
  Result += "    begin" + LineEnding;
  Result += "      if _SkipDirectory(directories[i]) then" + LineEnding;
  Result += "      begin" + LineEnding;
  Result += "        parents += _GetParent(directories[i]);" + LineEnding;
  Result += "        Delete(directories, i, 1);" + LineEnding;
  Result += "        deleteRoot := False;" + LineEnding;
  Result += "        Continue;" + LineEnding;
  Result += "      end;" + LineEnding + LineEnding;
  Result += "      if not parents.Contains(directories[i]) and not DeleteDirectory(directories[i], False) then" + LineEnding;
  Result += "        Exit;" + LineEnding;
  Result += "      Delete(directories, i, 1);" + LineEnding;
  Result += "    end;" + LineEnding;
  Result += "  end;" + LineEnding + LineEnding;
  Result += "  Result := not deleteRoot or DeleteDirectory(directory, False);" + LineEnding;
  Result += "end;" + LineEnding + LineEnding;
  Result += "function RMDir(const directory: String; deleteRoot: Boolean; skip: TStringArray = []): Boolean;" + LineEnding;
  Result += "begin" + LineEnding;
  Result += "  if not DeleteFiles(directory, skip) then" + LineEnding;
  Result += "    Exit;" + LineEnding + LineEnding;
  Result += "  Result := DeleteSubDirectories(directory, deleteRoot, skip);" + LineEnding;
  Result += "end;" + LineEnding + LineEnding + LineEnding;
  Result += "function IsFileLocked(path: String): Boolean;" + LineEnding;
  Result += "begin" + LineEnding;
  Result += "  if not FileExists(path) then" + LineEnding;
  Result += "    Exit;" + LineEnding + LineEnding;
  Result += "  if not BackupFile(path) then" + LineEnding;
  Result += "    TerminateScript('Failed to backup file: ' + path);" + LineEnding + LineEnding;
  Result += "  Result := not DeleteFile(path);" + LineEnding + LineEnding;
  Result += "  if Result then" + LineEnding;
  Result += "    DeleteFile(path + '.bak')" + LineEnding;
  Result += "  else if not RestoreFile(path) then" + LineEnding;
  Result += "    TerminateScript('Failed to restore file: ' + path);" + LineEnding;
  Result += "end;" + LineEnding + LineEnding;
  Result += "function FindLockedPlugins(): TStringArray;" + LineEnding;
  Result += "const" + LineEnding;
  Result += "  PATHS = [" + LineEnding;
  Result += "    IncludePath + 'SRL'   + SEP + 'plugins' + SEP + 'libremoteinput' + SEP," + LineEnding;
  Result += "    IncludePath + 'SRL-T' + SEP + 'plugins' + SEP + 'libremoteinput' + SEP" + LineEnding;
  Result += "  ];" + LineEnding;
  Result += "var" + LineEnding;
  Result += "  path, plugin: String;" + LineEnding;
  Result += "begin" + LineEnding;
  Result += "  for path in PATHS do" + LineEnding;
  Result += "    for plugin in FindFiles(path, False) do" + LineEnding;
  Result += "      if IsFileLocked(plugin) then" + LineEnding;
  Result += "        Result += plugin;" + LineEnding;
  Result += "end;" + LineEnding + LineEnding + LineEnding;
  Result += "procedure KillWindowByClass(name: String);" + LineEnding;
  Result += "var" + LineEnding;
  Result += "  window: TOSWindow;" + LineEnding;
  Result += "begin" + LineEnding;
  Result += "  for window in GetWindows().GetByClass(name) do" + LineEnding;
  Result += "    window.Kill();" + LineEnding;
  Result += "end;" + LineEnding + LineEnding;
  Result += "procedure KillSimbas();" + LineEnding;
  Result += "var" + LineEnding;
  Result += "  windows, simbas: TOSWindowArray;" + LineEnding;
  Result += "  win: TOSWindow;" + LineEnding;
  Result += "begin" + LineEnding;
  Result += "  windows := GetWindows();" + LineEnding;
  Result += "  simbas := windows.GetByTitleAndClass('Output,File Browser,Editor,Function List', 'Window');" + LineEnding + LineEnding;
  Result += "  if MessageDlg('Close Simba', 'Simba needs to be restarted.'," + LineEnding;
  Result += "     TMsgDlgType.mtConfirmation, [mbOK, mbAbort]) = 3 then" + LineEnding;
  Result += "    TerminateScript('You need to close all Simba windows to update SRL.');" + LineEnding + LineEnding;
  Result += "  for win in simbas do" + LineEnding;
  Result += "    win.Kill();" + LineEnding + LineEnding;
  Result += "  TerminateScript();" + LineEnding;
  Result += "end;" + LineEnding + LineEnding + LineEnding;
  Result += "procedure UnlockPlugins();" + LineEnding;
  Result += "var" + LineEnding;
  Result += "  locked: TStringArray;" + LineEnding;
  Result += "  plugin: String;" + LineEnding;
  Result += "begin" + LineEnding;
  Result += "  locked := FindLockedPlugins();" + LineEnding;
  Result += "  if locked = [] then" + LineEnding;
  Result += "    Exit;" + LineEnding + LineEnding;
  Result += "  if MessageDlg('Close RuneScape', 'RS Clients need to be closed to update this package.'," + LineEnding;
  Result += "     TMsgDlgType.mtConfirmation, [mbOK, mbAbort]) = 3 then" + LineEnding;
  Result += "    TerminateScript('You need to close your RS Clients to update SRL.');" + LineEnding + LineEnding;
  Result += "  KillWindowByClass('SunAwtCanvas');" + LineEnding + LineEnding;
  Result += "  for plugin in locked do" + LineEnding;
  Result += "    if IsFileLocked(plugin) then" + LineEnding;
  Result += "    begin" + LineEnding;
  Result += "      KillWindowByClass('Jagex Launcher');" + LineEnding;
  Result += "      Break;" + LineEnding;
  Result += "    end;" + LineEnding + LineEnding;
  Result += "  for plugin in locked do" + LineEnding;
  Result += "    if IsFileLocked(plugin) then" + LineEnding;
  Result += "    begin" + LineEnding;
  Result += "      KillSimbas();" + LineEnding;
  Result += "      Break;" + LineEnding;
  Result += "    end;" + LineEnding;
  Result += "end;" + LineEnding + LineEnding + LineEnding;
  Result += "procedure MoveFiles(origin, pkg: String);" + LineEnding;
  Result += "var" + LineEnding;
  Result += "  paths, files: TStringArray;" + LineEnding;
  Result += "  path, f, fPath, destination: String;" + LineEnding;
  Result += "begin" + LineEnding;
  Result += "  paths := GetDirectories(origin + pkg + SEP);" + LineEnding;
  Result += "  if Length(paths) <> 1 then" + LineEnding;
  Result += "    TerminateScript('The ' + pkg + ' download is empty or has unexpected things inside.');" + LineEnding + LineEnding;
  Result += "  destination := IncludePath + pkg + SEP;" + LineEnding;
  Result += "  if DirectoryExists(destination) and not RMDir(destination, True, ['.git', 'overrides.simba']) then" + LineEnding;
  Result += "    TerminateScript('Failed to delete old ' + pkg + ' library');" + LineEnding;
  Result += "  if not ForceDirectories(destination) then" + LineEnding;
  Result += "    TerminateScript('Failed to create path: ' + destination);" + LineEnding + LineEnding;
  Result += "  path := origin + pkg + SEP + paths[0] + SEP;" + LineEnding;
  Result += "  files := FindFiles(path, True);" + LineEnding + LineEnding;
  Result += "  for f in files do" + LineEnding;
  Result += "  begin" + LineEnding;
  Result += "    fPath := Replace(f, path, '', [rfReplaceAll]);" + LineEnding;
  Result += "    if Pos('.git', fPath) > 0 then" + LineEnding;
  Result += "      Continue;" + LineEnding + LineEnding;
  Result += "    if Pos('overrides.simba', fPath) > 0 then" + LineEnding;
  Result += "      Continue;" + LineEnding + LineEnding;
  Result += "    if not ForceDirectories(destination + ExtractFilePath(fPath)) then" + LineEnding;
  Result += "      TerminateScript('Failed to create path: ' + destination + ExtractFilePath(fPath));" + LineEnding + LineEnding;
  Result += "    if not CopyFile(f, destination + fPath, False) then" + LineEnding;
  Result += "      TerminateScript('Failed to copy file: ' + fPath);" + LineEnding + LineEnding;
  Result += "    DeleteFile(f);" + LineEnding;
  Result += "    if (FindFiles(ExtractFilePath(f), True) = []) and (FindDirectories(ExtractFilePath(f), True) = []) then" + LineEnding;
  Result += "      DeleteDirectory(ExtractFilePath(f), False);" + LineEnding;
  Result += "  end;" + LineEnding + LineEnding;
  Result += "  RMDir(origin + pkg, True);" + LineEnding;
  Result += "end;" + LineEnding + LineEnding;
  Result += "var" + LineEnding;
  Result += "  pkg: String;" + LineEnding + LineEnding;
  Result += "procedure Free();" + LineEnding;
  Result += "begin" + LineEnding;
  Result += "  CloseFile(CreateFile({$MACRO CURRENT_DIRECTORY} + 'mover-' + LowerCase(pkg) + '.done'));" + LineEnding;
  Result += "end;" + LineEnding + LineEnding;
  Result += "begin" + LineEnding;
  Result += "  pkg := GetProcessParameter('pkg');" + LineEnding + LineEnding;
  Result += "  if FileExists({$MACRO CURRENT_DIRECTORY} + 'mover-' + LowerCase(pkg) + '.done') then" + LineEnding;
  Result += "    DeleteFile({$MACRO CURRENT_DIRECTORY} + 'mover-' + LowerCase(pkg) + '.done');" + LineEnding + LineEnding;
  Result += "  AddOnTerminate(@Free);" + LineEnding + LineEnding;
  Result += "  case LowerCase(pkg) of" + LineEnding;
  Result += "    'srl-t', 'srlt', 'srl': UnlockPlugins();" + LineEnding;
  Result += "  end;" + LineEnding + LineEnding;
  Result += "  WriteLn('[AsyncMover]: Moving ', pkg, ' files, this will take a while.');" + LineEnding;
  Result += "  MoveFiles(GetProcessParameter('origin'), pkg);" + LineEnding;
  Result += "end;" + LineEnding;
end;

function TWaspAsync.GetServerContent(): String;
begin
  Result += "//Credits: Slacky" + LineEnding;
  Result += "function String.After(SubStr: String; p: Int32): String; constref;" + LineEnding;
  Result += "begin" + LineEnding;
  Result += "  Inc(p, Length(SubStr));" + LineEnding;
  Result += "  Result := Copy(Self, p, Length(Self) - p + 1);" + LineEnding;
  Result += "end;" + LineEnding + LineEnding;
  Result += "type" + LineEnding;
  Result += "  TSimbaServerClient = record" + LineEnding;
  Result += "    ID: Int32;" + LineEnding;
  Result += "    IP, Port: String;" + LineEnding;
  Result += "    IsSetup: Boolean;" + LineEnding;
  Result += "  end;" + LineEnding + LineEnding;
  Result += "  TSimbaServer = record" + LineEnding;
  Result += "    ID: Int32;" + LineEnding;
  Result += "    IP, Port: String;" + LineEnding;
  Result += "    Client: TSimbaServerClient;" + LineEnding;
  Result += "  end;" + LineEnding + LineEnding;
  Result += "procedure TSimbaServerClient.CloseAndFree();" + LineEnding;
  Result += "begin" + LineEnding;
  Result += "  if not Self.IsSetup then Exit;" + LineEnding;
  Result += "  CloseSocket(Self.ID);" + LineEnding;
  Result += "  FreeSocket(Self.ID);" + LineEnding;
  Result += "  Self.IsSetup := False;" + LineEnding;
  Result += "end;" + LineEnding + LineEnding;
  Result += "procedure TSimbaServerClient.WriteString(s: string);" + LineEnding;
  Result += "begin" + LineEnding;
  Result += "  SendSocket(Self.ID, s);" + LineEnding;
  Result += "end;" + LineEnding + LineEnding;
  Result += "function TSimbaServerClient.SendHTML(content: String): Boolean;" + LineEnding;
  Result += "var" + LineEnding;
  Result += "  headers, html: String;" + LineEnding;
  Result += "begin" + LineEnding;
  Result += "  html :=" + LineEnding;
  Result += "  '<!DOCTYPE html>' + LineEnding +" + LineEnding;
  Result += "    '<html>' + LineEnding +" + LineEnding;
  Result += "    '  <head>' + LineEnding +" + LineEnding;
  Result += "    '    <meta charset=''UTF-8''>' + LineEnding +" + LineEnding;
  Result += "    '    <link rel=''icon'' href=''https://waspscripts.com/favicon.png''>' + LineEnding +" + LineEnding;
  Result += "    '    <meta name=''viewport'' content=''width=device-width''>' + LineEnding +" + LineEnding;
  Result += "    '    <title>WaspScripts</title>'  + LineEnding +" + LineEnding;
  Result += "    '    <meta name=''description'' content=''WaspScripts Simba Login page''>' + LineEnding +" + LineEnding;
  Result += "    '    <style>' + LineEnding +" + LineEnding;
  Result += "    '      body {' + LineEnding +" + LineEnding;
  Result += "    '         background-color: #222324;' + LineEnding +" + LineEnding;
  Result += "    '         color: white;' + LineEnding +" + LineEnding;
  Result += "    '         display: flex;' + LineEnding +" + LineEnding;
  Result += "    '         justify-content: center;' + LineEnding +" + LineEnding;
  Result += "    '         height: 100vh;' + LineEnding +" + LineEnding;
  Result += "    '         text-align: center;' + LineEnding +" + LineEnding;
  Result += "    '         flex-direction: column;' + LineEnding +" + LineEnding;
  Result += "    '      }' + LineEnding +" + LineEnding;
  Result += "    '    </style>' + LineEnding +" + LineEnding + LineEnding;
  Result += "    '  </head>' + LineEnding +" + LineEnding;
  Result += "    ' <body>' + LineEnding +" + LineEnding;
  Result += "        content + LineEnding +" + LineEnding;
  Result += "    ' </body>' + LineEnding +" + LineEnding;
  Result += "  '</html>';" + LineEnding + LineEnding;
  Result += "  headers += 'HTTP/1.1 200 OK' + #13#10;" + LineEnding;
  Result += "  headers += 'Content-Type: text/html'+#13#10;" + LineEnding;
  Result += "  headers += 'Connection: close'+#13#10;" + LineEnding;
  Result += "  headers += 'Content-Length: ' + IntToStr(Length(html))+#13#10#13#10;" + LineEnding + LineEnding;
  Result += "  Result := True;" + LineEnding;
  Result += "  try" + LineEnding;
  Result += "    Self.WriteString(headers + html);" + LineEnding;
  Result += "  except" + LineEnding;
  Result += "    Exit(False);" + LineEnding;
  Result += "  end;" + LineEnding;
  Result += "end;" + LineEnding + LineEnding + LineEnding;
  Result += "function TSimbaServerClient.Read(): String; overload;" + LineEnding;
  Result += "begin" + LineEnding;
  Result += "  Result := RecvSocketStr(Self.ID);" + LineEnding;
  Result += "end;" + LineEnding + LineEnding + LineEnding;
  Result += "procedure TSimbaServer.CloseAndFree();" + LineEnding;
  Result += "begin" + LineEnding;
  Result += "  CloseSocket(Self.ID);" + LineEnding;
  Result += "  FreeSocket(Self.ID);" + LineEnding;
  Result += "end;" + LineEnding + LineEnding;
  Result += "function TSimbaServer.AttemptSocketBind(): Boolean;" + LineEnding;
  Result += "begin" + LineEnding;
  Result += "  try BindSocket(Self.ID, Self.IP, Self.Port); except Exit end;" + LineEnding;
  Result += "  Result := True;" + LineEnding;
  Result += "end;" + LineEnding + LineEnding;
  Result += "procedure TSimbaServer.Setup();" + LineEnding;
  Result += "var" + LineEnding;
  Result += "  attempt: Int32;" + LineEnding;
  Result += "begin" + LineEnding;
  Result += "  Self.ID   := CreateSocket();" + LineEnding;
  Result += "  Self.IP   := '127.0.0.1';" + LineEnding;
  Result += "  Self.Port := '5217';" + LineEnding + LineEnding;
  Result += "  for attempt := 0 to 200 do" + LineEnding;
  Result += "  begin" + LineEnding;
  Result += "    if Self.AttemptSocketBind() then Break;" + LineEnding;
  Result += "    Sleep(100);" + LineEnding;
  Result += "  end;" + LineEnding + LineEnding;
  Result += "  ListenSocket(Self.ID);" + LineEnding;
  Result += "  Self.Client.ID := -1;" + LineEnding;
  Result += "end;" + LineEnding + LineEnding;
  Result += "procedure TSimbaServer.AcceptClient();" + LineEnding;
  Result += "begin" + LineEnding;
  Result += "  Self.Client.IsSetup := True;" + LineEnding;
  Result += "  Self.Client.ID := AcceptSocket(Self.ID);" + LineEnding;
  Result += "  SocketInfo(Self.Client.ID, Self.Client.IP, Self.Client.Port);" + LineEnding;
  Result += "end;" + LineEnding + LineEnding;
  Result += "function TSimbaServer.Listen(): String;" + LineEnding;
  Result += "var" + LineEnding;
  Result += "  tmp, header, path: String;" + LineEnding;
  Result += "  i: Int32" + LineEnding;
  Result += "begin" + LineEnding;
  Result += "  try SetSocketTimeout(Self.Client.ID, 2000); except Exit; end;" + LineEnding + LineEnding;
  Result += "  //Writeln('Connection from: ', client.IP, ':', client.Port);" + LineEnding + LineEnding;
  Result += "  repeat" + LineEnding;
  Result += "    try" + LineEnding;
  Result += "      tmp := Self.Client.Read();" + LineEnding;
  Result += "      header += tmp;" + LineEnding;
  Result += "    except" + LineEnding;
  Result += "      Exit; //client is DC'ed." + LineEnding;
  Result += "    end;" + LineEnding;
  Result += "  until tmp = '';" + LineEnding + LineEnding;
  Result += "  path := Between('GET ', ' HTTP/1.1', header);" + LineEnding + LineEnding;
  Result += "  i := Pos('?error=', path);" + LineEnding;
  Result += "  if i > 0 then" + LineEnding;
  Result += "    if not client.SendHTML('<h1>Login failed with error message:</h1><p>' + path.After('?error=', i) + '</p><h2>Close this page and try again.</h2>') then Exit;" + LineEnding + LineEnding;
  Result += "  i := Pos('?code=', path);" + LineEnding;
  Result += "  if i > 0 then" + LineEnding;
  Result += "  begin" + LineEnding;
  Result += "    Result := path.After('?code=', i);" + LineEnding;
  Result += "    if not Self.Client.SendHTML('<h1>You''ve successfully logged in!</h1><h2>You can now close this page.</h2>') then Exit;" + LineEnding;
  Result += "  end;" + LineEnding + LineEnding;
  Result += "  Self.Client.CloseAndFree();" + LineEnding;
  Result += "end;" + LineEnding + LineEnding;
  Result += "var" + LineEnding;
  Result += "  HealthChecker: TTimer;" + LineEnding;
  Result += "  Timeout: UInt64;" + LineEnding;
  Result += "  Server: TSimbaServer;" + LineEnding;
  Result += "  {$IFDEF SIMBAHEADLESS}" + LineEnding;
  Result += "  LauncherPID: PtrUInt;" + LineEnding;
  Result += "  {$ENDIF}" + LineEnding;
  Result += "  Code: String;" + LineEnding + LineEnding;
  Result += "procedure HealthCheck(sender: TObject);" + LineEnding;
  Result += "begin" + LineEnding;
  Result += "  if (GetTickCount() <= Timeout) and" + LineEnding;
  Result += "      {$IFDEF SIMBAHEADLESS} IsProcessRunning(LauncherPID) and {$ENDIF}" + LineEnding;
  Result += "      not FileExists({$MACRO CURRENT_DIRECTORY} + 'server-stop') then Exit;" + LineEnding + LineEnding;
  Result += "  DeleteFile({$MACRO CURRENT_DIRECTORY} + 'server-stop');" + LineEnding;
  Result += "  CloseFile(CreateFile({$MACRO CURRENT_DIRECTORY} + 'server-failed.done'));" + LineEnding + LineEnding;
  Result += "  TTimer(sender).setEnabled(False);" + LineEnding;
  Result += "  RaiseException('Server timed out!');" + LineEnding;
  Result += "end;" + LineEnding + LineEnding;
  Result += "procedure RunHealthCheck();" + LineEnding;
  Result += "begin" + LineEnding;
  Result += "  HealthChecker.SetOnTimer(@HealthCheck);" + LineEnding;
  Result += "  HealthChecker.SetEnabled(True);" + LineEnding;
  Result += "end;" + LineEnding + LineEnding;
  Result += "begin" + LineEnding;
  Result += "  DeleteFile({$MACRO CURRENT_DIRECTORY} + 'server-stop');" + LineEnding;
  Result += "  {$IFDEF SIMBAHEADLESS}" + LineEnding;
  Result += "  LauncherPID := Variant(GetProcessParameter('LauncherPID'));" + LineEnding;
  Result += "  {$ENDIF}" + LineEnding + LineEnding;
  Result += "  Server.Setup();" + LineEnding;
  Result += "  AddOnTerminate(@Server.CloseAndFree);" + LineEnding;
  Result += "  AddOnTerminate(@Server.Client.CloseAndFree);" + LineEnding;
  Result += "  AddOnTerminate(@HealthChecker.Free);" + LineEnding + LineEnding;
  Result += "  Timeout := GetTickCount() + 5 * 60 * 1000;" + LineEnding;
  Result += "  HealthChecker.Init(nil);" + LineEnding + LineEnding;
  Result += "  HealthChecker.SetInterval(150);" + LineEnding;
  Result += "  Sync(@RunHealthCheck);" + LineEnding + LineEnding;
  Result += "  repeat" + LineEnding;
  Result += "    Server.AcceptClient();" + LineEnding;
  Result += "    code := Server.Listen();" + LineEnding;
  Result += "  until code <> '';" + LineEnding + LineEnding;
  Result += "  WriteFileContents({$MACRO CURRENT_DIRECTORY} + 'server-success.done', code, False);" + LineEnding + LineEnding;
  Result += "  HealthChecker.setEnabled(False);" + LineEnding;
  Result += "end;" + LineEnding;
end;

procedure TWaspAsync.Setup();
begin
  Self.Path := LAUNCHER_DATA + 'async' + DirectorySeparator;

  if not ForceDirectories(LAUNCHER_DATA) then
    TerminateScript('WaspAsync failed to create directory: ' + LAUNCHER_DATA);

  if DirectoryExists(Self.Path) and not RMDir(Self.Path, True) then
    TerminateScript('WaspAsync failed to delete old files. Please manually delete:' + Self.Path);

  if DirectoryExists(LAUNCHER_DATA + 'downloads') and not RMDir(LAUNCHER_DATA + 'downloads') then
    TerminateScript('WaspAsync failed to delete old files. Please manually delete: ' + LAUNCHER_DATA + 'downloads' + DirectorySeparator);

  if not ForceDirectories(Self.Path) then
    TerminateScript('WaspAsync can''t create async directory.');

  Self.Write('downloader.simba', Self.GetDownloaderContent());
  Self.Write('unzipper.simba', Self.GetUnzipperContent());
  Self.Write('mover.simba', Self.GetMoverContent());
  Self.Write('server.simba', Self.GetServerContent());
end;

var
  WaspAsync: TWaspAsync;


{$IFNDEF WS_CONFIG_INCLUDED}       
(*
# Config
A full featured JSON config writer and reader.
*)

{$DEFINE WL_CONFIG_INCLUDED}


function TJSONObject.getBoolean(key: String; acceptNull: Boolean): Boolean; constref; overload;
begin
  if not acceptNull then
    Exit(Self.getBoolean(key));

  Result := (Self <> nil) and Self.has(key) and not Self.isNull(key) and Self.getBoolean(key);
end;

function TJSONObject.put(key: string; Value: Boolean): TJSONObject; constref; override;
begin
  Self.Remove(key);
  Result := inherited(key, value);
end;

function TJSONObject.put(key: string; Value: Double): TJSONObject; constref; override;
begin
  Self.Remove(key);
  Result := inherited(key, value);
end;

function TJSONObject.put(key: string; Value: Integer): TJSONObject; constref; override;
begin
  Self.Remove(key);
  Result := inherited(key, value);
end;

function TJSONObject.put(key: string; Value: String): TJSONObject; constref; override;
begin
  Self.Remove(key);
  Result := inherited(key, value);
end;

function TJSONObject.put(key: string; Value: Pointer): TJSONObject; constref; override;
begin
  Self.Remove(key);
  Result := inherited(key, value);
end;


function TJSONObject.toString(): String; constref; override;
begin
  Result := inherited;
  Result := Result.ReplaceAll(
              [
                ['\u003A', ':'], ['\u0020', ' '],
                ['},{', '},' + LineEnding + '  {'],
                ['[{', '[' + LineEnding + '  {'],
                ['}]', '}' + LineEnding + ']']
              ]);
end;

function TJSONObject.toString(indentFactor: Integer): String; constref; override;
begin
  Result := inherited(indentFactor);
  Result := Result.ReplaceAll(
              [
                ['\u003A', ':'], ['\u0020', ' '],
                ['},{', '},' + LineEnding + '  {'],
                ['[{', '[' + LineEnding + '  {'],
                ['}]', '}' + LineEnding + ']']
              ]);
end;

function TJSONArray.toString(): String; constref; override;
begin
  Result := inherited;
  Result := Result.ReplaceAll(
              [
                ['\u003A', ':'], ['\u0020', ' '],
                ['},{', '},' + LineEnding + '  {'],
                ['[{', '[' + LineEnding + '  {'],
                ['}]', '}' + LineEnding + ']']
              ]);
end;

function TJSONArray.toString(indentFactor: Integer): String; constref; override;
begin
  Result := inherited(indentFactor);
  Result := Result.ReplaceAll(
              [
                ['\u003A', ':'], ['\u0020', ' '],
                ['},{', '},' + LineEnding + '  {'],
                ['[{', '[' + LineEnding + '  {'],
                ['}]', '}' + LineEnding + ']']
              ]);
end;


type
(*
(TConfigJSON)=
## type TConfigJSON
```pascal
TConfigJSON = record
  Path: String;
  JSON: TJSONObject;
end;
```
*)
  TConfigJSON = record
    Path: String;
    JSON: TJSONObject;
    IsSetup, OnTerminate: Boolean;       //Don't touch.
  end;

(*
## TConfigJSON.GetConfig
```pascal
function TConfigJSON.GetConfig(): TJSONObject;
```
Helper method to return the current TConfigJSON.Path file as a TJSONObject.
You probably don't need to use this directly.
*)
function TConfigJSON.GetConfig(): TJSONObject;
var
  str: String;
begin
  if FileExists(Self.Path) then
  begin
    str := ReadFileContents(Self.Path);
    if str <> '' then
    begin
      try
        Result.Init(str);
      except
        Result := nil;
        Result.Init();
      end;
      Exit;
    end;
  end;

  Result.Init();
end;

(*
## TConfigJSON.Free
```pascal
procedure TConfigJSON.Free();
```
Used to free your `TConfigJSON`.
It's automatically called on script termination, but you may call it sooner if
you wish to unlock the ram used by this (which should be minimal).
*)
procedure TConfigJSON.Free();
begin
  if not Self.IsSetup then Exit;

  Self.JSON.Free();
  Self.JSON := nil;

  Self.IsSetup := False;
end;

(*
## TConfigJSON.Setup
```pascal
procedure TConfigJSON.Setup(jsonFile: String);
```
Main method to setup your `TConfigJSON`
*)
procedure TConfigJSON.Setup(jsonFile: String = ScriptName);
begin
  if jsonFile.Contains(DirectorySeparator) then
  begin
    Self.Path := ExtractFilePath(jsonFile);
    jsonFile := ExtractFileName(jsonFile);
  end
  else
    Self.Path := AppPath + 'Configs' + DirectorySeparator;

  if not ForceDirectories(Self.Path) then
    TerminateScript('Can''t create configs directory.');

  if not jsonFile.EndsWith('.json') then
    jsonFile += '.json';
  Self.Path += jsonFile;

  Self.JSON := Self.GetConfig();
  Self.IsSetup := True;

  if not Self.OnTerminate then
  begin
    AddOnTerminate(@Self.Free);
    Self.OnTerminate := True;
  end;
end;

(*
## TConfigJSON.DeleteConfig
```pascal
procedure TConfigJSON.DeleteConfig();
```
Delete your `TConfigJSON` from disk.
*)
procedure TConfigJSON.DeleteConfig();
begin
  if not DeleteFile(Self.Path) then
    TerminateScript('Failed to delete: ' + Self.Path);
end;

(*
## TConfigJSON.SaveConfig
```pascal
procedure TConfigJSON.SaveConfig();
```
Used to save your `TConfigJSON`.
By default, this is always called automatically whenever the config is modified by the {ref}`TConfigJSON.Put()` methods.
*)
procedure TConfigJSON.SaveConfig();
begin
  if Self.JSON = nil then
    TerminateScript('You need to use TConfigJSON.Setup() before trying to save it into a config file.');

  if not WriteFileContents(Self.Path, json.ToString(1), False) then
    TerminateScript('Failed to save config.');
end;


(*
## TConfigJSON.Put
```pascal
procedure TConfigJSON.Put(key, value: String; save: Boolean = True);
procedure TConfigJSON.Put(key: String; value: Int32; save: Boolean = True); overload;
procedure TConfigJSON.Put(key: String; value: Double; save: Boolean = True); overload;
procedure TConfigJSON.Put(key: String; value: Boolean; save: Boolean = True); overload;
procedure TConfigJSON.Put(key: String; value: Pointer; save: Boolean = True); overload;
```
This should be self explanatory. Put a `key` and a `value` pair into your `TConfigJSON`.
The `pointer` version of the method is the only one that might need a little bit more knowledge of
Simba's lower JSON methods and/or pointers but you can use it to place a value that is another JSON object or a JSON array.
*)
procedure TConfigJSON.Put(key, value: String; save: Boolean = True);
begin
  if Self.JSON = nil then
    Exit;
  Self.JSON.Put(key, value);
  if save then
    Self.SaveConfig();
end;

procedure TConfigJSON.Put(key: String; value: Int32; save: Boolean = True); overload;
begin
  if Self.JSON = nil then
    Exit;
  Self.JSON.Put(key, value);
  if save then
    Self.SaveConfig();
end;

procedure TConfigJSON.Put(key: String; value: Double; save: Boolean = True); overload;
begin
  if Self.JSON = nil then
    Exit;
  Self.JSON.Put(key, value);
  if save then
    Self.SaveConfig();
end;

procedure TConfigJSON.Put(key: String; value: Boolean; save: Boolean = True); overload;
begin
  if Self.JSON = nil then
    Exit;
  Self.JSON.Put(key, value);
  if save then
    Self.SaveConfig();
end;

procedure TConfigJSON.Put(key: String; value: Pointer; save: Boolean = True); overload;
begin
  if Self.JSON = nil then
    Exit;
  Self.JSON.put(key, value);
  if save then
    Self.SaveConfig();
end;


(*
## TConfigJSON.Has
```pascal
function TConfigJSON.Has(key: String; nullIsValid: Boolean = True): Boolean;
```
Checks if a key exists. `nullIsValid` is true by default when set to false
this will return false if the key exists but is set to null.
*)
function TConfigJSON.Has(key: String; nullIsValid: Boolean = True): Boolean;
begin
  if Self.JSON = nil then
    Exit;
  Result := Self.JSON.has(key);

  if not nullIsValid and Result then
    Result := not Self.JSON.isNull(key);
end;


(*
## TConfigJSON.Get
```pascal
function TConfigJSON.GetString(key: String): String;
function TConfigJSON.GetInt(key: String): Int32;
function TConfigJSON.GetDouble(key: String): Double;
function TConfigJSON.GetBoolean(key: String): Boolean;
function TConfigJSON.GetNull(key: String): Boolean;
function TConfigJSON.GetObject(key: String): TJSONObject;
function TConfigJSON.GetArray(key: String): TJSONArray;
```
This should be self explanatory. Returns the value of a `key` in your `TConfigJSON`.
The `Object` version of the method is the only one that might need a little bit more knowledge of
Simba's lower JSON methods and/or pointers but you can use it to return a JSON object or a TJSONArray of TJSONObjects.
*)
function TConfigJSON.GetString(key: String): String;
begin
  if Self.JSON = nil then
    Exit;
  if Self.JSON.has(key) and not Self.JSON.isNull(key) then
    Result := Self.JSON.getString(key);
end;

function TConfigJSON.GetInt(key: String): Integer;
begin
  if Self.JSON = nil then
    Exit;
  if Self.JSON.has(key) and not Self.JSON.isNull(key) then
    Result := Self.JSON.getInt(key);
end;

function TConfigJSON.GetDouble(key: String): Double;
begin
  if Self.JSON = nil then
    Exit;
  if Self.JSON.has(key) and not Self.JSON.isNull(key) then
    Result := Self.JSON.getDouble(key);
end;

function TConfigJSON.GetBoolean(key: String): Boolean;
begin
  if Self.JSON = nil then
    Exit;
  if Self.JSON.has(key) and not Self.JSON.isNull(key) then
    Result := Self.JSON.getBoolean(key);
end;

function TConfigJSON.GetNull(key: String): Boolean;
begin
  if Self.JSON = nil then
    Exit;
  Result := not Self.JSON.has(key) or Self.JSON.isNull(key);
end;

function TConfigJSON.GetObject(key: String): TJSONObject;
begin
  if Self.JSON = nil then
    Exit;
  if Self.JSON.has(key) and not Self.JSON.isNull(key) then
    Result := Self.JSON.getJSONObject(key);
end;

function TConfigJSON.GetArray(key: String): TJSONArray;
begin
  if Self.JSON = nil then
    Exit;
  if Self.JSON.has(key) and not Self.JSON.isNull(key) then
    Result := Self.JSON.getJSONArray(key);
end;


(*
## TConfigJSON.Remove
```pascal
procedure TConfigJSON.Remove(key: String);
```
Remove a `key` and it's respective `value` from your `TConfigJSON`.
*)
procedure TConfigJSON.Remove(key: String);
begin
  if Self.JSON = nil then
    TerminateScript('You need to use TConfigJSON.Setup() before trying to delete a key on it.');
  Self.JSON.remove(key);
  Self.SaveConfig();
end;


(*
## TConfigJSON.ToString
```pascal
function TConfigJSON.ToString(indentFactor: Int32 = 2): String;
```
Returns a string version of your `TConfigJSON`.

Example:
```pascal
WriteLn MyConfig.ToString();
```
*)
function TConfigJSON.ToString(indentFactor: Int32 = 2): String;
begin
  if Self.JSON = nil then
    Exit;
  Result := Self.JSON.ToString(indentFactor);
end;

type
(*
(TConfigINI)=
## type TConfigINI
```pascal
TConfigINI = record
  Path: String;
  FileName: String;
end;
```
Example:
```pascal
ConfigINI.Setup('MyScriptSettings.ini'); // Set file path
ConfigINI.Put('GUISettings', 'UsePoolPOH', 'True'); // Write setting
WriteLn(ConfigINI.Get('GUISettings', 'UsePoolPOH')); // Read setting
WriteLn(ConfigINI.GetKeys('GUISettings')); // List all keys in 'GUISettings'
```
*)
  TConfigINI = record
    Path: String;
    FileName: String;
  end;

(*
## TConfigINI.Setup
```pascal
procedure TConfigINI.Setup(ConfigName: String);
```
Initializes configuration path and filename.

Example:
```pascal
ConfigINI.Setup('MyScriptSettings.ini');
```
*)
procedure TConfigINI.Setup(ConfigName: String);
begin
  if ConfigName.Contains(DirectorySeparator) then
  begin
    Self.Path := ExtractFilePath(ConfigName);
    ConfigName := ExtractFileName(ConfigName);
  end
  else
    Self.Path := AppPath + 'Configs' + DirectorySeparator;

  if not ForceDirectories(Self.Path) then
    TerminateScript('Can''t create configs directory.');

  if not ConfigName.EndsWith('.ini') then
    ConfigName += '.ini';
  Self.Path += ConfigName;
end;


(*
## TConfigINI.Put
```pascal
procedure TConfigINI.Put(Section, KeyName, Value: String);
```
Writes a single key-value pair to a specified section.

Example:
```pascal
ConfigINI.Put('GUISettings', 'UsePoolPOH', 'True');
```
*)
procedure TConfigINI.Put(Section, KeyName, Value: String);
begin
  WriteINI(Section, KeyName, Value, Self.Path);
end;


(*
## TConfigINI.Get
```pascal
function TConfigINI.Get(Section, KeyName: String): String;
function TConfigINI.Get(Section, KeyName, DefaultValue: String): String; overload;
```
Retrieves a single value by key from a specified section.

Example:
```pascal
WriteLn(ConfigINI.Get('GUISettings', 'UsePoolPOH'));
```
*)
function TConfigINI.Get(Section, KeyName: String): String;
begin
  Result := ReadINI(Section, KeyName, Self.Path);
end;

function TConfigINI.Get(Section, KeyName, DefaultValue: String): String; overload;
begin
  Result := ReadINI(Section, KeyName, Self.Path);
  if Result = '' then Result := DefaultValue;
end;

(*
## TConfigINI.GetKeys
```pascal
function TConfigINI.GetKeys(Section: String): TStringArray;
```
Retrieves all keys from a specified section.

Example:
```pascal
WriteLn(ConfigINI.GetKeys('GUISettings'));
```
*)
function TConfigINI.GetKeys(Section: String): TStringArray;
var
  FileContent: TStringArray;
var
  i: Int32;
  InSection: Boolean;
begin
  if not FileExists(Self.Path) then
    RaiseException('File does not exist: ' + Self.Path);

  FileContent := ReadFileContents(Self.Path).Split(#10);
  while i < Length(FileContent) do begin
    FileContent[i] := FileContent[i].Trim;
    if FileContent[i].StartsWith('[') and FileContent[i].EndsWith(']') then begin
      InSection := FileContent[i].Between('[', ']') = Section;
    end else if InSection and FileContent[i].Contains('=') then begin
      Result += FileContent[i].Before('=').Trim;
    end;
    Inc(i);
  end;
end;


(*
## TConfigINI.Remove
```pascal
procedure TConfigINI.Remove(Section, KeyName: String);
```
Removes a single key-value pair from a specified section.

Example:
```pascal
ConfigINI.Remove('GUISettings', 'UsePoolPOH'));
```
*)
procedure TConfigINI.Remove(Section, KeyName: String);
begin
  if not FileExists(Self.Path) then
    RaiseException('File does not exist: ' + Self.Path);
  DeleteINI(Section, KeyName, Self.Path);
end;


(*
## TConfigINI.DeleteConfig
```pascal
procedure TConfigINI.DeleteConfig();
```
Deletes the entire configuration file.

Example:
```pascal
ConfigINI.DeleteConfig();
```
*)
procedure TConfigINI.DeleteConfig();
begin
  if FileExists(Self.Path) then
    DeleteFile(Self.Path)
  else
    RaiseException('File does not exist: ' + Self.Path);
end;


{$IFNDEF WS_HTTP_INCLUDED}         
(*
# HTTPClients
Responsible connecting to the internet.
*)

{$DEFINE WS_HTTP_INCLUDED}


var
  LauncherConfig: TConfigJSON;

type
  THTTPClient = record
    Name: String;
    Client: Int32;
    Server: String;
  end;

function THTTPClient.GetHTTPCode(): Int32;
begin
  Result := GetHTTPResponseCode(Self.Client);
end;

procedure THTTPClient.Free();
begin
  FreeHTTPClient(Self.Client);
end;


function THTTPClient.GET(route: String; verbose: Boolean = True): String;
var
  time: UInt64;
begin
  time := GetTickCount();
  Result := GetHTTPPage(Self.Client, Self.Server + route);
  time := GetTickCount() - time;
  Result := StringReplace(Result, '\u0020', ' ', [rfReplaceAll]);
  if verbose then
    {$IFNDEF DEVELOPER_MODE}
    DebugLn(Self.Name, 'HTTPCode: ' + ToStr(Self.GetHTTPCode()) + ' - ' + Result + ' - Response took: ' + ToStr(time) + 'ms.');
    {$ELSE}
    DebugLn(Self.Name, 'HTTPCode: ' + ToStr(Self.GetHTTPCode()) + ' - Response took: ' + ToStr(time) + 'ms.');
    {$ENDIF}
end;

function THTTPClient.GETEx(route, destination: String; verbose: Boolean = True): Boolean;
var
  time: UInt64;
  response: String;
begin
  time := GetTickCount();
  response := GetHTTPPage(Self.Client, Self.Server + route);
  Result := (Self.GetHTTPCode() = 200) and WriteFileContents(destination, response, False);
  time := GetTickCount() - time;

  if verbose then
    {$IFNDEF DEVELOPER_MODE}
    DebugLn(Self.Name, 'HTTPCode: ' + ToStr(Self.GetHTTPCode()) + ' - ' + ExtractFileName(destination) + ' - Download took: ' + ToStr(time) + 'ms.');
    {$ELSE}
    DebugLn(Self.Name, 'HTTPCode: ' + ToStr(Self.GetHTTPCode()) + ' - Download took: ' + ToStr(time) + 'ms.');
    {$ENDIF}
end;


function THTTPClient.POST(route: String; verbose: Boolean = True): String;
var
  time: UInt64;
begin
  time := GetTickCount();
  ClearPostData(Self.Client);
  Result := PostHTTPPageEx(Self.Client, Self.Server + route);
  time := GetTickCount() - time;
  Result := StringReplace(Result, '\u0020', ' ', [rfReplaceAll]);
  if verbose then
    {$IFNDEF DEVELOPER_MODE}
    DebugLn(Self.Name, 'HTTPCode: ' + ToStr(Self.GetHTTPCode()) + ' - ' + Result + ' - Response took: ' + ToStr(time) + 'ms.');
    {$ELSE}
    DebugLn(Self.Name, 'HTTPCode: ' + ToStr(Self.GetHTTPCode()) + ' - Response took: ' + ToStr(time) + 'ms.');
    {$ENDIF}
end;

function THTTPClient.POST(route: String; payload: String; verbose: Boolean = True): String; overload;
var
  time: UInt64;
begin
  time := GetTickCount();
  Result := PostHTTPPage(Self.Client, Self.Server + route, payload);
  time := GetTickCount() - time;
  Result := StringReplace(Result, '\u0020', ' ', [rfReplaceAll]);
  if verbose then
    {$IFNDEF DEVELOPER_MODE}
    DebugLn(Self.Name, 'HTTPCode: ' + ToStr(Self.GetHTTPCode()) + ' - ' + Result + ' - Response took: ' + ToStr(time) + 'ms.');
    {$ELSE}
    DebugLn(Self.Name, 'HTTPCode: ' + ToStr(Self.GetHTTPCode()) + ' - Response took: ' + ToStr(time) + 'ms.');
    {$ENDIF}
end;

function THTTPClient.POST(route: String; payload: TJSONObject; verbose: Boolean = True): String; overload;
begin
  Result := Self.POST(route, payload.toString(), verbose);
end;


(*
# GithubClient
Responsible for connecting to GitHub. Because of the way Simba HTTPClients work,
it's easier to have different clients for different servers when they use different headers.

Unaunthenticated requests to the GitHub API have a limit of 60 requests per hour per IP.
This should be more than enough for our use case since running this script should never really
do more than 3 (checking versions) or 6 (checking versions + downloading packages) requests per run.
*)
type
  TGitHubClient = record(THTTPClient)
    DownloadPath: String;
    Packages: record
      Current: record
        SRLT: String;
        WaspLib: String;
      end;
      Latest: record
        SRLT: String;
        WaspLib: String;
      end;
      Release: record
        SRLT: String;
        WaspLib: String;
      end;
    end;
  end;

procedure TGitHubClient.RefreshClient(isSetup: Boolean = True);
begin
  if isSetup then Self.Free();
  Self.Client := InitializeHTTPClient(True);

  SetHTTPContentType(Self.Client, 'application/json');
  SetHTTPHeader(Self.Client, 'Accept', 'application/vnd.github+json');
end;

function TGitHubClient.GetLatestPackage(pkg: String): TJSONObject;
const
  ROUTE: String = 'repos/Torwent/';
var
  response: String;
begin
  try
    response := Self.GET(ROUTE + pkg + '/releases/latest', {$IFDEF FULL_DEVELOPER_MODE}True{$ELSE}{$IFDEF DEVELOPER_MODE}True{$ELSE}False{$ENDIF}{$ENDIF});

    if Self.GetHTTPCode() = 200 then
      Result.Init(response);
  except
    TerminateScript(GetExceptionMessage());
  end;
end;

function TGitHubClient.GetCurrentPackageVersion(pkg: String): String;
var
  path: String;
begin
  path := INCLUDEPATH + pkg + DIRECTORYSEPARATOR + 'CHANGELOG.md';

  Result := ReadFileContents(path);
  Result := Result.After('# [').Before('](https');
end;

procedure TGitHubClient.Setup();
var
  json: TJSONObject;
begin
  Self.Name := 'GitHub Client';
  Self.Server := 'https://api.github.com/';
  Self.DownloadPath := LAUNCHER_DATA + 'downloads' + DirectorySeparator;

  if not ForceDirectories(Self.DownloadPath) then
    TerminateScript('GitHubClient can''t create downloads directory.');

  Self.RefreshClient(False);
  AddOnTerminate(@Self.Free);

  Self.Packages.Current.SRLT := Self.GetCurrentPackageVersion('srl-t');
  Self.Packages.Current.WaspLib := Self.GetCurrentPackageVersion('wasplib');

  json := Self.GetLatestPackage('SRL-T');
  if json <> nil then
  begin
    Self.Packages.Latest.SRLT := json.getString('name').After('v');
    Self.Packages.Release.SRLT := json.getString('zipball_url');
    json.Free();
  end
  else
    Self.Packages.Latest.SRLT := 'failed';

  json := Self.GetLatestPackage('WaspLib');
  if json <> nil then
  begin
    Self.Packages.Latest.WaspLib := json.getString('name').After('v');
    Self.Packages.Release.WaspLib := json.getString('zipball_url');
    json.Free();
  end
  else
    Self.Packages.Latest.WaspLib := 'failed';
end;


procedure TGitHubClient.Download(pkg: String);
var
  url: String;
  params: TStringArray;
begin
  case LowerCase(pkg) of
    'srlt', 'srl-t': url := Self.Packages.Release.SRLT;
    'wl', 'wasplib': url := Self.Packages.Release.WaspLib;
    else
      TerminateScript('Unrecognized package to download: ' + pkg);
  end;

  params := ['url=' + url,'destination="'+ Self.DownloadPath + pkg + '.zip"', 'pkg=' + pkg];
  WaspAsync.Run('downloader', params);
end;


var
  GitHubClient: TGitHubClient;

(*
# WaspClient
Responsible for connecting to waspscripts.com database.
Because of the way Simba HTTPClients work, it's easier to have different clients
for different servers when they use different headers.
*)
type
  TRolesData = record
    Banned: Boolean;
    Premium: Boolean;
    VIP: Boolean;
    Tester: Boolean;
    Scripter: Boolean;
    Moderator: Boolean;
    Administrator: Boolean;
  end;

  EScriptStatus = (OFFICIAL, COMMUNITY);
  EScriptType = (FREE, PREMIUM, PREMIUM_NO_SUB);

  TScriptData = record
    ID: String;
    Name: String;
    Description: String;
    Content: String;
    URL: String;
    Status: EScriptStatus;
    Typ: EScriptType;
    Revision: Int32;
  end;

  TScriptDataArray = array of TScriptData;

  TBundleData = record
    ID: String;
    Product: String;
    Name: String;
    Owner: String;
    Scripts: TScriptDataArray;
  end;

  TBundleDataArray = array of TBundleData;

  TProductData = record
    ID: String;
    Owner: String;
    Bundle: String;
    Script: String;
  end;
  TProductDataArray = array of TProductData;

  TSubscriptionData = record
    Product: String;
    DateStart: String;
    DateEnd: String;
  end;
  TSubscriptionDataArray = array of TSubscriptionData;

function TScriptDataArray.Find(const id: String): Int32; constref;
begin
  for Result := 0 to High(Self) do
    if Self[Result].ID = id then
      Exit;
  Result := -1;
end;

function TScriptDataArray.Contains(const id: String): Boolean; constref;
begin
  Result := Self.Find(id) > -1;
end;

function ScriptDataSort(constref left, right: TScriptData): Int32;
begin
  if LowerCase(left.Name) > LowerCase(right.Name) then
    Exit(1);
  if LowerCase(left.Name) < LowerCase(right.Name) then
    Exit(-1);
end;

function TScriptDataArray.Sorted(): TScriptDataArray;
begin
  Result := System.Sorted(Self, @ScriptDataSort);
end;

type
  TWaspClient = record(THTTPClient)
    Schema: String;
    APIKey: String;
    DownloadPath: String;
    AssetsPath: String;
    PKCEVerifier: String;

    Cache: record
      User: record
        AccessToken: String;
        RefreshToken: String;
        ID: String;
        Username: String;

        UserData: TJSONObject;
        Roles: TRolesData;
        Subscriptions: TSubscriptionDataArray;
        FreeAccess: TSubscriptionDataArray;
        UnsubscribedScripts : TScriptDataArray;
        SubscribbedProducts: TProductDataArray;
        FreeAccessProducts: TProductDataArray;
        SubscribbedScripts: TScriptDataArray;
        AllUserScripts: TScriptDataArray;
      end;

      Launcher: TScriptData;
      Scripts: TScriptDataArray;
      FreeScripts: TScriptDataArray;
      PremiumScripts: TScriptDataArray;

      Bundles: TBundleDataArray;
      Products: TProductDataArray;

      Free: Boolean;
    end;
  end;

procedure TWaspClient.FreeUserData();
begin
  if Self.Cache.Free then
    Exit;

  Self.Cache.User := [];
  Self.Cache.User.Roles := [];
  Self.Cache.User.SubscribbedProducts := [];
  Self.Cache.User.FreeAccessProducts := [];
  Self.Cache.User.SubscribbedScripts := [];
  Self.Cache.User.AllUserScripts := [];

  Self.Cache.User.UserData.Free();
  Self.Cache.User.UserData := nil;

  Self.Cache.Free := True;
end;

procedure TWaspClient.Free(); override;
begin
  FreeHTTPClient(Self.Client);
  Self.FreeUserData();
end;

(*
There's some bug that makes it required to "refresh" the client after logging in.
Oh Simba... you never stop surprising me.
*)
procedure TWaspClient.RefreshClient(isSetup: Boolean = True);
begin
  if isSetup then
    FreeHTTPClient(Self.Client);
  Self.Client := InitializeHTTPClient(True);

  SetHTTPContentType(Self.Client, 'application/json');
  SetHTTPHeader(Self.Client, 'apikey', Self.APIKey);
  if Self.Cache.User.AccessToken <> '' then
    SetHTTPHeader(Self.Client, 'Authorization', 'Bearer ' + Self.Cache.User.AccessToken);
end;

procedure TWaspClient.SaveRefreshToken();
begin
  if Self.Cache.User.RefreshToken <> '' then
    LauncherConfig.Put('refresh_token', Self.Cache.User.RefreshToken);
end;


//Login
function TWaspClient.Login(grantType: String; payload: TJSONObject): Boolean;
const
  ROUTE: String = 'auth/v1/token';
  QUERY: String = '?grant_type=';
var
  response: TJSONObject;
begin
  try
    response.Init(Self.POST(ROUTE + QUERY + grantType, payload, False));
    if Self.GetHTTPCode() = 200 then
    begin
      Self.Cache.User.AccessToken := response.getString('access_token');
      Self.Cache.User.RefreshToken := response.getString('refresh_token');
      Self.Cache.User.ID := response.getJSONObject('user').getString('id');
      Self.Cache.User.Username := response.getJSONObject('user').getJSONObject('user_metadata').getJSONObject('custom_claims').getString('global_name');
      Self.RefreshClient();
      Self.SaveRefreshToken();
      Self.Cache.Free := False;

      Self.GetAllUserScripts();
      Exit(True);
    end;

    Self.Cache.User := [];
    LauncherConfig.Remove('refresh_token');
    Self.FreeUserData();
  except
    WriteLn('Error logging in: ', GetExceptionMessage());
    if response <> nil then
      TerminateScript('Response: ' + response.ToString());
  finally
    payload.Free();
    if response <> nil then
      response.Free();
  end;
end;

function TWaspClient.Login(user, password: String): Boolean; overload;
var
  payload: TJSONObject;
begin
  payload.Init();
  payload.Put('email', user);
  payload.Put('password', password);
  Result := Self.Login('password', payload);
end;

function TWaspClient.Login(refreshToken: String): Boolean; overload;
var
  payload: TJSONObject;
begin
  payload.Init();
  payload.Put('refresh_token', refreshToken);
  Result := Self.Login('refresh_token', payload);
end;


function TWaspClient.GeneratePKCEVerifier(challengeLength: Int32 = 56): String;
const
  CHARS = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-._~';
var
  i, n: Int32;
begin
  n := Length(CHARS);
  for i := 1 to challengeLength do
    Result += CHARS[Random(n) + 1];
end;



function TWaspClient.GeneratePKCEChallenge(verifier: String): String;
  {$R-}
  //Hex2Bytes by slacky
  function Hex2Bytes(const hexStr: string): TByteArray;
  var i: Int32;
  const
    lookup: array[48..70] of Byte = [
      0, 1, 2, 3, 4, 5, 6, 7, 8, 9,   // '0' to '9'
      0, 0, 0, 0, 0, 0, 0,
      10, 11, 12, 13, 14, 15          // 'A' to 'F'
    ];
  begin
    if (Length(hexStr) mod 2 <> 0) then Exit;
    SetLength(Result, Length(hexStr) div 2);

    for i := 1 to Length(hexStr) with 2 do
      Result[i shr 1] := (lookup[Byte(hexStr[i])] shl 4) or lookup[Byte(hexStr[i+1])];
  end;

  function Base64UrlEncode(const data: TByteArray): string;
  const
    BASE64URLTable: string = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_';
  var
    i, j: Integer;
    triplet: Cardinal;
    pad: Integer;
  begin
    while i < Length(data) do
    begin
      triplet := 0;
      pad := 0;

      // Read up to 3 bytes into a 24-bit integer
      for j := 0 to 2 do
      begin
        triplet := triplet shl 8;
        if (i + j < Length(data)) then
          triplet := triplet or data[i + j]
        else
          Inc(pad);  // Count missing bytes for padding
      end;

      // Convert 24-bit integer into four 6-bit values and map to Base64URL
      for j := 0 to 3 - pad do
        Result += BASE64URLTable[(triplet shr ((3 - j) * 6)) and $3F + 1];

      i := i + 3;
    end;
  end;
  {$R+}
var
  bytes: TByteArray;
begin
  verifier := Hash(THashType.htSHA256, verifier);
  bytes := Hex2Bytes(verifier);
  Result := Base64UrlEncode(bytes);
end;


procedure TWaspClient.StartOAuth2Login(provider: String = 'discord'; method: String = 's256');
const
  ROUTE: String = 'auth/v1/authorize';
  SERVER_PORT: String = '5217';
var
  code, query: String;
  response: TJSONObject;
begin
  Self.PKCEVerifier := Self.GeneratePKCEVerifier();

  case method of
    'plain': code := Self.PKCEVerifier;
    's256':  code := GeneratePKCEChallenge(Self.PKCEVerifier);
    else     RaiseException('Unknown PKCE method: ' + method);
  end;

  query := '?provider=' + provider;
  query += '&redirect_to=http%3A%2F%2Flocalhost%3A' + SERVER_PORT + '%2F';
  query += '&scopes=identify%20email%20guilds%20guilds.members.read';
  query += '&code_challenge=' + code;
  query += '&code_challenge_method=' + method;
  OpenWebPage(Self.Server + ROUTE + query);
end;

function TWaspClient.FinishOAuth2Login(auth_code: String): Boolean;
const
  ROUTE: String = 'auth/v1/token';
  QUERY: String = '?grant_type=pkce';
var
  payload, response: TJSONObject;
begin
  payload.Init();
  payload.Put('auth_code', auth_code);
  payload.Put('code_verifier', Self.PKCEVerifier);
  Self.PKCEVerifier := '';

  try
    response.Init(Self.POST(ROUTE + QUERY, payload, False));

    if Self.GetHTTPCode() = 200 then
    begin
      Self.Cache.User.AccessToken := response.getString('access_token');
      Self.Cache.User.RefreshToken := response.getString('refresh_token');
      Self.Cache.User.ID := response.getJSONObject('user').getString('id');
      Self.Cache.User.Username := response.getJSONObject('user').getJSONObject('user_metadata').getJSONObject('custom_claims').getString('global_name');
      Self.RefreshClient();
      Self.SaveRefreshToken();
      Self.Cache.Free := False;

      Self.GetAllUserScripts();
      Exit(True);
    end;

    Self.Cache.User := [];
    LauncherConfig.Remove('refresh_token');
    Self.FreeUserData();
  except
    WriteLn('Error logging in: ', GetExceptionMessage());
    if response <> nil then
      TerminateScript('Response: ' + response.ToString());
  finally
    payload.Free();
    if response <> nil then
      response.Free();
  end;
end;





function TWaspClient.GetUserData(): TJSONObject;
const
  ROUTE: String = 'auth/v1/user';
var
  response: String;
begin
  if Self.Cache.User.UserData <> nil then
    Exit(Self.Cache.User.UserData);

  try
    response := Self.GET(ROUTE, False);
    if Self.GetHTTPCode() = 200 then
    begin
      Result.Init(response);
      Self.Cache.User.UserData := Result;
    end;
  except
    TerminateScript(GetExceptionMessage());
  end;
end;

function TWaspClient.Logout(): Boolean;
const
  ROUTE: String = 'auth/v1/logout';
begin
  try
    Self.POST(ROUTE, False);
    Result := Self.GetHTTPCode() = 204;
    if Result then
    begin
      Self.FreeUserData();
      LauncherConfig.Remove('refresh_token');
    end;
  except
    TerminateScript(GetExceptionMessage());
  end;
end;

function TWaspClient.IsLoggedIn(): Boolean;
begin
  Result := Self.Cache.User.AccessToken <> '';
end;

procedure TWaspClient.LoadRefreshToken();
var
  token: String;
begin
  token := LauncherConfig.GetString('refresh_token');
  if (token <> '') then
  begin
    if Self.Login(token) then
      DebugLn(Self.Name, 'Previous session refreshed!')
    else
      Self.RefreshClient(True);
  end;
end;



procedure TWaspClient.SetSchema(schema: String);
begin
  if schema = 'public' then
    schema := ''; //public schema is just not having the header.

  if Self.Schema <> schema then
    SetHTTPHeader(Self.Client, 'Accept-Profile', schema);
end;


function TWaspClient.GetRoles(): TRolesData;
const
  ROUTE: String = 'rest/v1/roles';
var
  query: String = '?select=banned,premium,vip,tester,scripter,moderator,administrator';
  response: String;
  tmp: TJSONArray;
begin
  if Self.Cache.User.Roles <> [] then
    Exit(Self.Cache.User.Roles);

  Self.SetSchema('profiles');
  query += '&id=eq.' + Self.Cache.User.ID + '&limit=1';
  try
    response := Self.GET(ROUTE + query, False);
    if Self.GetHTTPCode() = 200 then
    begin
      tmp.Init(response);
      if tmp.length > 0 then
      begin
        Result.Banned := tmp.getJSONObject(0).getString('banned') = 'true';
        Result.Premium := tmp.getJSONObject(0).getString('premium') = 'true';
        Result.VIP := tmp.getJSONObject(0).getString('vip') = 'true';
        Result.Tester := tmp.getJSONObject(0).getString('tester') = 'true';
        Result.Scripter := tmp.getJSONObject(0).getString('scripter') = 'true';
        Result.Moderator := tmp.getJSONObject(0).getString('moderator') = 'true';
        Result.Administrator := tmp.getJSONObject(0).getString('administrator') = 'true';
        Self.Cache.User.Roles := Result;
      end;
      tmp.Free();
    end;
  except
    TerminateScript(GetExceptionMessage());
  end;
end;

function TWaspClient.Select(schema, table, query: String; filters: TStringArray = []; orders: TStringArray = []): TJSONArray;
const
  ROUTE: String = 'rest/v1/';
var
  response: String;
begin
  Self.SetSchema(schema);

  if filters <> [] then
    query += '&' + Implode('&', filters);

  if orders <> [] then
    query += '&order=' + Implode('&order=', orders);

  try
    response := Self.GET(ROUTE + table + '?select=' + query, False);

    if Self.GetHTTPCode() = 200 then
      Result.Init(response);
  except
    TerminateScript(GetExceptionMessage());
  end;
end;


//You can try mess with what's below here but same checks are done on the database policies.
function TWaspClient.GetSubscriptions(): TSubscriptionDataArray;
var
  jsonArray: TJSONArray;
  i: Int32;
  sub: TSubscriptionData;
begin
  if Self.Cache.User.Subscriptions <> [] then
    Exit(Self.Cache.User.Subscriptions);
  jsonArray := Self.Select('profiles', 'subscription', 'product,date_start,date_end', ['id=eq.' + Self.Cache.User.ID]);

  for i := 0 to jsonArray.High() do
  begin
    with jsonArray.getJSONObject(i) do
    begin
      sub.Product := getString('product');
      sub.DateStart := getString('date_start');
      sub.DateEnd := getString('date_end');
    end;

    Result += sub;
  end;

  Self.Cache.User.Subscriptions := Result;
end;

function TWaspClient.GetFreeAccess(): TSubscriptionDataArray;
var
  jsonArray: TJSONArray;
  i: Int32;
  sub: TSubscriptionData;
begin
  if Self.Cache.User.FreeAccess <> [] then
    Exit(Self.Cache.User.FreeAccess);
  jsonArray := Self.Select('profiles', 'free_access', 'product,date_start,date_end', ['id=eq.' + Self.Cache.User.ID]);

  for i := 0 to jsonArray.High() do
  begin
    with jsonArray.getJSONObject(i) do
    begin
      sub.Product := getString('product');
      sub.DateStart := getString('date_start');
      sub.DateEnd := getString('date_end');
    end;

    Result += sub;
  end;

  Self.Cache.User.FreeAccess := Result;
end;


function TWaspClient.GetScripts(): TScriptDataArray;
  function _parseDate(fulldate: String): String;
  var
    time: String;
    yy, mm, dd: String;
  begin
    yy := fulldate.Before('-');
    mm := fulldate.After('-').Before('-');
    dd := fulldate.After('-').After('-').Before('T');
    time := fulldate.After('T').Before('.');

    Result := dd + '/' + mm + '/' + yy + ', ' + time;
  end;

var
  jsonArray, categories: TJSONArray;
  i, j: Int32;
  script: TScriptData;
begin
  if Self.Cache.Scripts <> [] then
    Exit(Self.Cache.Scripts);
  jsonArray := Self.Select(
                  'scripts',
                  'scripts',
                  'id,product,title,description,content,url,protected!inner(revision,username,revision_date),metadata!inner(status,type)',
                  ['published=eq.true'],
                  ['title.asc']
               );

  for i := 0 to jsonArray.High() do
  begin
    with jsonArray.getJSONObject(i) do
    begin
      script.ID := getString('id');
      script.Name := getString('title');
      script.Description := getString('description');
      script.Content := getString('content');
      script.URL := getString('url');
      script.Revision := getJSONObject('protected').getInt('revision');

      script.Content := script.Content.
                        Replace('{$id}', script.ID).
                        Replace('{$title}', script.Name).
                        Replace('{$description}', script.Description).
                        Replace('{$revision}', ToStr(script.Revision)).
                        Replace('{$author}', getJSONObject('protected').getString('username')).
                        Replace('{$revision_date}', _parseDate(getJSONObject('protected').getString('revision_date')).Before(',')).
                        Replace('{$last_revision_date}', _parseDate(getJSONObject('protected').getString('revision_date')).Before(',')).
                        Replace('{$last_revision_time}', _parseDate(getJSONObject('protected').getString('revision_date')).After(', ')).
                        Replace('{$last_revision_full_date}', _parseDate(getJSONObject('protected').getString('revision_date')));

      case getJSONObject('metadata').getString('status') of
        'official':  script.Status := EScriptStatus.OFFICIAL;
        'community': script.Status := EScriptStatus.COMMUNITY;
        else raise 'Script ' + script.ID + ' is missing a status.';
      end;

      case getJSONObject('metadata').getString('type') of
        'free':    script.Typ := EScriptType.FREE;
        'premium': script.typ := EScriptType.PREMIUM;
        else raise 'Script ' + script.ID + ' is missing a type.';
      end;
    end;

    if script.ID = {$MACRO SCRIPT_ID} then
      Self.Cache.Launcher := script
    else
      Result += script;
    script := [];
  end;

  jsonArray.Free();

  Self.Cache.Scripts := Result;
end;


function TWaspClient.GetFreeScripts(): TScriptDataArray;
var
  scripts: TScriptDataArray;
  i: Int32;
begin
  if Self.Cache.FreeScripts <> [] then
    Exit(Self.Cache.FreeScripts);

  scripts := Self.GetScripts();
  for i := 0 to High(scripts) do
    if scripts[i].Typ = EScriptType.FREE then
      Result += scripts[i];

  Self.Cache.FreeScripts := Result;
end;

function TWaspClient.GetPremiumScripts(): TScriptDataArray;
var
  scripts: TScriptDataArray;
  i, j: Int32;
begin
  if Self.Cache.PremiumScripts <> [] then
    Exit(Self.Cache.PremiumScripts);

  scripts := Self.GetScripts();
  for i := 0 to High(scripts) do
    if scripts[i].Typ = EScriptType.PREMIUM then
      Result += scripts[i];

  Self.Cache.PremiumScripts := Result;
end;

function TWaspClient.GetBundles(): TBundleDataArray;
var
  jsonArray, scriptsJSON: TJSONArray;
  i, j, n: Int32;
  bundle: TBundleData;
  scripts: TScriptDataArray;
begin
  if Self.Cache.Bundles <> [] then
    Exit(Self.Cache.Bundles);
  jsonArray := Self.Select('scripts', 'bundles', 'product,id,name,scripts,user_id');

  scripts := Self.GetPremiumScripts();

  for i := 0 to jsonArray.High() do
    with jsonArray.getJSONObject(i) do
    begin
      bundle.ID := getString('id');
      bundle.Product := getString('product');
      bundle.Name := getString('name');
      bundle.Owner := getString('user_id');

      scriptsJSON := getJSONArray('scripts');
      for j := 0 to scriptsJSON.High() do
        for n := 0 to High(scripts) do
          if scripts[n].ID = scriptsJSON.getString(j) then
            bundle.Scripts += scripts[n];

      Result += bundle;
      bundle := [];
    end;

  jsonArray.Free();

  Self.Cache.Bundles := Result;
end;

function TWaspClient.GetBundledScripts(id: String): TScriptDataArray;
var
  bundles: TBundleDataArray;
  i: Int32;
begin
  bundles := Self.GetBundles();

  for i := 0 to High(bundles) do
  begin
    if bundles[i].ID <> id then
      Continue;

    Exit(bundles[i].Scripts);
  end;
end;


function TWaspClient.GetProducts(): TProductDataArray;
var
  jsonArray: TJSONArray;
  product: TProductData;
  i: Int32;
begin
  if Self.Cache.Products <> [] then
    Exit(Self.Cache.Products);
  jsonArray := Self.Select('scripts', 'products', 'id,user_id,bundle,script');

  for i := 0 to jsonArray.High() do
  begin
    with jsonArray.getJSONObject(i) do
    begin
      product.ID := getString('id');
      product.Owner := getString('user_id');
      product.Bundle := getString('bundle');
      product.Script := getString('script');
    end;
    Result += product;
  end;
  jsonArray.Free();

  Self.Cache.Products := Result;
end;


procedure TWaspClient.Setup();
var
  response: TJSONObject;
begin
  Self.Name := 'WaspClient';
  Self.Server := 'https://api.waspscripts.com/';
  Self.Client := InitializeHTTPClient(True);
  try
    response.Init(Self.GET('', False));
    Self.Server := response.getString('url');
    Self.APIKey := response.getString('anon_key');
  except
    WriteLn 'Failed to connect to https://api.waspscripts.com/ to get the database connection info.';
    WriteLn 'Falling back to previously known good values';
    Self.Server := 'https://db.waspscripts.com/';
    Self.APIKey := 'eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJpc3MiOiJzdXBhYmFzZSIsImlhdCI6MTcxOTQ5MDgwMCwiZXhwIjo0ODc1MTY0NDAwLCJyb2xlIjoiYW5vbiJ9.pKuuhYK-xxOWBHg3mqaxNptyvCpE5n-cjhxN3GQKr2I';
  finally
    FreeHTTPClient(Self.Client);
    response.Free();
  end;

  if Self.APIKey = '' then
    TerminateScript();

  if not Self.Server.EndsWith('/') then Self.Server += '/';

  Self.DownloadPath := LAUNCHER_DATA + 'downloads' + DirectorySeparator;
  Self.AssetsPath := LAUNCHER_DATA + 'assets' + DirectorySeparator;

  if not ForceDirectories(Self.DownloadPath) then
    TerminateScript('WaspClient can''t create downloads directory.');

  Self.RefreshClient(False);
  AddOnTerminate(@Self.Free);
  Self.LoadRefreshToken();

  //Pre-load data...
  Self.GetProducts();
  Self.GetBundles();
  Self.GetFreeScripts();
end;


function TWaspClient.GetSubscribbedProducts(): TProductDataArray;
var
  subs: TSubscriptionDataArray;
  products: TProductDataArray;
  i, j: Int32;
begin
  if Self.Cache.User.SubscribbedProducts <> [] then
    Exit(Self.Cache.User.SubscribbedProducts);

  subs := Self.GetSubscriptions();
  products := Self.GetProducts();

  for i := 0 to High(subs) do
    for j := High(products) downto 0 do
    begin
      if subs[i].Product <> products[j].ID then
        Continue;
      Result += products[j];
      Delete(products, j, 1);
      Break;
    end;

  Self.Cache.User.SubscribbedProducts := Result;
end;

function TWaspClient.GetFreeAccessProducts(): TProductDataArray;
var
  free: TSubscriptionDataArray;
  products: TProductDataArray;
  roles: TRolesData;
  i, j: Int32;
begin
  if Self.Cache.User.FreeAccessProducts <> [] then
    Exit(Self.Cache.User.FreeAccessProducts);

  free := Self.GetFreeAccess();
  products := Self.GetProducts();
  roles := Self.GetRoles();

  for i := 0 to High(free) do
    for j := High(products) downto 0 do
    begin
      if free[i].Product <> products[j].ID then
        Continue;
      Result += products[j];
      Delete(products, j, 1);
      Break;
    end;

  if roles.Tester or roles.Moderator or roles.Administrator then
    for i := 0 to High(products) do
      Result += products[i];

  Self.Cache.User.FreeAccessProducts := Result;
end;


function TWaspClient.GetAccessScripts(): TScriptDataArray;
var
  subs, freeAccess: TProductDataArray;
  scripts, bundled: TScriptDataArray;
  i, j: Int32;
begin
  if Self.Cache.User.SubscribbedScripts <> [] then
    Exit(Self.Cache.User.SubscribbedScripts);

  scripts := Self.GetPremiumScripts();
  subs := Self.GetSubscribbedProducts();
  freeAccess := Self.GetFreeAccessProducts();

  for i := 0 to High(subs) do
  begin
    if subs[i].Script = 'null' then
    begin
      bundled := Self.GetBundledScripts(subs[i].Bundle);
      for j := 0 to High(bundled) do
        if not Result.Contains(bundled[j].ID) then
          Result += bundled[j];
    end;

    for j := 0 to High(scripts) do
    begin
      if scripts[j].ID <> subs[i].Script then
        Continue;

      if not Result.Contains(scripts[j].ID) then
        Result += scripts[j];
    end;
  end;

  for i := 0 to High(freeAccess) do
  begin
    if freeAccess[i].Script = 'null' then
    begin
      bundled := Self.GetBundledScripts(freeAccess[i].Bundle);

      for j := 0 to High(bundled) do
        if not Result.Contains(bundled[j].ID) then
          Result += bundled[j];
    end;

    for j := 0 to High(scripts) do
    begin
      if scripts[j].ID <> freeAccess[i].Script then
        Continue;
      if not Result.Contains(scripts[j].ID) then
        Result += scripts[j];
    end;
  end;

  Self.Cache.User.SubscribbedScripts := Result;
end;

function TWaspClient.GetUnsubscribedScripts() : TScriptDataArray;
var
   i, j : Int32;
   all, subbed : TScriptDataArray;
begin
  if Self.Cache.User.UnsubscribedScripts <> [] then
    Exit(Self.Cache.User.UnsubscribedScripts);

  all := Self.GetPremiumScripts();
  subbed := Self.GetAccessScripts();

  for i := 0 to High(all) do
  begin
    if subbed.Find(all[i].ID) > -1 then
      continue;

    Result += all[i];
  end;

  Self.Cache.User.UnsubscribedScripts := Result;
end;

function TWaspClient.GetAllUserScripts(): TScriptDataArray;
begin
  if Self.Cache.User.AllUserScripts <> [] then
    Exit(Self.Cache.User.AllUserScripts);

  Result := Self.GetPremiumScripts() + Self.GetFreeScripts();
  Result := Result.Sorted();

  Self.Cache.User.AllUserScripts := Result;
end;

procedure TWaspClient.ApplyNoSubPremiumType()
var
  i : int32;
  unSubbed, access : TScriptDataArray;
begin
  //Get the unsubscribed stuff.
  unSubbed := Self.GetUnsubscribedScripts();

  //Get what they actually have
  access := Self.GetAccessScripts();

  for i := 0 to High(Self.Cache.User.AllUserScripts) do
  begin
    if unSubbed.Find(Self.Cache.User.AllUserScripts[i].ID) > -1 then
    begin
      Self.Cache.User.AllUserScripts[i].Typ := EScriptType.PREMIUM_NO_SUB;
    end;
  end;
end;

function TWaspClient.Storage(route: String): String;
var
  response: String;
begin
  try
    response := Self.GET(route, False);
    if Self.GetHTTPCode() = 200 then
      Result := response;
  except
    TerminateScript(GetExceptionMessage());
  end;
end;

function TWaspClient.Storage(bucket, path: String): String; overload;
const
  ROUTE: String = 'storage/v1/object/authenticated/';
begin
  Result := Self.Storage(ROUTE + bucket + '/' + path);
end;

function TWaspClient.StorageGetSignedURL(bucket, path: String; expiresIn: UInt32 = 10): String;
const
  ROUTE: String = 'storage/v1/object/sign/';
var
  response: String;
  payload, json: TJSONObject;
begin
  payload.Init();
  payload.Put('expiresIn', expiresIn);

  try
    response := Self.POST(ROUTE + bucket + '/' + path, payload, False);
    if Self.GetHTTPCode() = 200 then
    begin
     json.Init(response);
     Result := 'storage/v1' + json.getString('signedURL');
     json.Free();
    end;
  except
    TerminateScript(GetExceptionMessage());
  finally
    payload.Free();
  end;
end;


procedure TWaspClient.DownloadScript(name, id: String; revision: Int32);
const
  ROUTE: String = 'storage/v1/object/authenticated/scripts/';
var
  url, revStr: String;
begin
  revStr := PadL(ToStr(revision), 9, '0');
  url := ROUTE + id + '/' + revStr + '/script.simba';

  DebugLn(Self.Name, 'Downloading ' + name + ' rev. ' + ToStr(revision) + ' this might take a while.');
  if not Self.GETEx(url, Self.DownloadPath + name + '.simba') then
    TerminateScript('Something went wrong while trying to download: ' + url);
end;

function TWaspClient.DownloadScriptEx(id: String; revision: Int32): Boolean;
const
  ROUTE: String = 'storage/v1/object/public/scripts/';
var
  url, revStr: String;
begin
  revStr := PadL(ToStr(revision), 9, '0');
  url := ROUTE + id + '/' + revStr + '/script.simba';

  DebugLn(Self.Name, 'Downloading ' + id + ' this might take a while.');
  Result := Self.GETEx(url, Self.DownloadPath + id + '.simba');
end;


procedure TWaspClient.DownloadImage(id, img: String);
const
  ROUTE: String = 'storage/v1/object/authenticated/imgs/scripts/';
var
  url: String;
  path: String;
begin
  url := ROUTE + id + '/' + img + '.jpg';

  path := Self.AssetsPath + id + DirectorySeparator;
  if not ForceDirectories(path) then
    TerminateScript('Failed to create assets path: ' + id);

  if not Self.GETEx(url, path + img + '.jpg') then
  begin
    url := ROUTE + 'default/' + img + '.jpg';
    if not Self.GETEx(url, path + img + '.jpg') then
      TerminateScript('Something went wrong while trying to download: ' + url);
  end;
end;


procedure TWaspClient.RunTests(user, password: String);
begin
  if Self.Cache.User.AccessToken = '' then
    Self.Login(user, password);

  WriteLn('UserData: ', Self.GetUserData().ToString());
  WriteLn('Roles:', Self.GetRoles());
  WriteLn('Subscription:', Self.GetSubscriptions());
  WriteLn('FreeAccess:', Self.GetFreeAccess());
  WriteLn('Scripts:', Self.GetScripts());
  WriteLn('Bundles:', Self.GetBundles());
  WriteLn('Products:', Self.GetProducts());
  WriteLn('SubbedProducts:', Self.GetSubscribbedProducts());
  WriteLn('BundledScripts:', Self.GetBundledScripts('86a1dbfc-338d-4c98-87c7-29b875549d9b'));
  WriteLn('SubbedScripts:', Self.GetAccessScripts());
end;

var
  WaspClient: TWaspClient;


{$IFNDEF WS_FORMUTILS_INCLUDED}    
{$DEFINE WS_FORMUTILS_INCLUDED}


function TControl.GetDPI(): Int32; static;
var
  tmp: TFont;
begin
  tmp.Init();
  Result := tmp.GetPixelsPerInch();
  tmp.Free();
end;

function TControl.AdjustToDPI(n: Int32): Int32; static;
begin
  Result := Round(n * TControl.GetDPI() / 96);
end;

function TControl.ReverseAdjustToDPI(n: Int32): Int32; static;
begin
  Result := Round(n / TControl.GetDPI() / 96);
end;


procedure TPanel.Create(owner: TControl);
begin
  Self.Init(owner);
  Self.SetParent(owner);
end;

procedure TPageControl.Create(owner: TControl);
begin
  Self.Init(owner);
  Self.SetParent(owner);
end;

procedure TTabSheet.Create(owner: TControl);
begin
  Self.Init(owner);
  Self.SetParent(owner);
end;

procedure TImage.Create(owner: TControl);
begin
  Self.Init(owner);
  Self.SetParent(owner);
end;

procedure TLabel.Create(owner: TControl);
begin
  Self.Init(owner);
  Self.SetParent(owner);
end;

procedure TEdit.Create(owner: TControl);
begin
  Self.Init(owner);
  Self.SetParent(owner);
end;

procedure TButton.Create(owner: TControl);
begin
  Self.Init(owner);
  Self.SetParent(owner);
  Self.SetHeight(TControl.AdjustToDPI(20));
end;

procedure TCheckBox.Create(owner: TControl);
begin
  Self.Init(owner);
  Self.SetParent(owner);
end;

procedure TRadioButton.Create(owner: TControl);
begin
  Self.Init(owner);
  Self.SetParent(owner);
end;

procedure TComboBox.Create(owner: TControl);
begin
  Self.Init(owner);
  Self.SetParent(owner);
end;

procedure TListBox.Create(owner: TControl);
begin
  Self.Init(owner);
  Self.SetParent(owner);
end;

procedure TMemo.Create(owner: TControl);
begin
  Self.Init(owner);
  Self.SetParent(owner);
end;


procedure TControl.SetFontColor(color: TColor);
begin
  Self.GetFont().setColor(color);
end;

procedure TControl.SetFontSize(size: Int32);
begin
  Self.GetFont().setSize(TControl.ReverseAdjustToDPI(size));
end;

procedure TControl.SetFontQuality(quality: TFontQuality);
begin
  Self.GetFont().setQuality(quality);
end;

procedure TControl.SetFontStyle(qualities: TFontStyles);
begin
  Self.GetFont().setStyle(qualities);
end;



procedure TCheckBox.SetChecked(value: Boolean);
begin
  if value then
    Self.setState(cbChecked)
  else
    Self.setState(cbUnchecked);
end;

function TCheckBox.IsChecked(): Boolean;
begin
  Result := Self.getState() = cbChecked;
end;

procedure TCheckBox.Toggle();
begin
  case Self.getState() of
    cbChecked: Self.setState(cbUnchecked);
    else Self.setState(cbChecked)
  end;
end;


function TControl.GetTrueWidth(): Int32;
var
  bmp: TBitmap;
  canvas: TCanvas;
  font: TFont;
begin
  if Self = nil then
    Exit;

  bmp.Init();
  try
    canvas := bmp.getCanvas();
    font := Self.getFont();

    if font <> nil then
    begin
      canvas.setFont(font);
      Result := canvas.TextWidth(Self.getCaption());
    end;
  finally
    bmp.Free();
  end;
end;

function TControl.GetTrueHeight(): Int32;
var
  bmp: TBitmap;
  canvas: TCanvas;
  font: TFont;
begin
  if Self = nil then
    Exit;

  bmp.Init();
  try
    canvas := bmp.getCanvas();
    font := Self.getFont();
    if font <> nil then
    begin
      canvas.setFont(font);
      Result := canvas.TextHeight(Self.getCaption());
    end;
  finally
    bmp.Free();
  end;
end;


function TComponent.NameMatch(name: TComponentName): Boolean;
begin
  Result := (Self <> nil) and (Self.GetName() = name);
end;

function TComponent.GetChild(name: TComponentName): TComponent;
var
  i: Int32;
  child: TComponent;
begin
  if Self = nil then
    Exit;

  if Self.GetName() = name then
    Exit(Self);

  for i := 0 to Self.getComponentCount() - 1 do
  begin
    child := Self.GetComponent(i);
    Result := child.GetChild(name);
    if Result <> nil then
      Exit;
  end;
end;


procedure TImage.LoadFromFile(path: String);
var
  name, extension: String;
begin
  if Pos(APPPATH, path) = 0 then
    path := APPPATH + path;

  Self.getPicture().LoadFromFile(path);

  name := ExtractFileName(path);
  extension := ExtractFileExt(name);

  name := 'image_' + StringReplace(LowerCase(name), extension, '', [rfReplaceAll]);
  Self.SetName(name);
end;

procedure TControl.LoadFromFile(path: String);
var
  img: TImage;
begin
  img.Create(Self);
  img.LoadFromFile(path);

  img.SetBounds(0, 0, Self.getWidth(), Self.getHeight());
  img.SetStretch(True);
  img.SetProportional(True);

  img.setAlign(alClient);
end;

procedure TControl.SwapImage(path: String);
var
  hi, i: Int32;
  child: TControl;
begin
  hi := Self.getComponentCount()-1;

  if hi < 0 then
  begin
    Self.LoadFromFile(path);
    Exit;
  end;

  for i := 0 to hi do
  begin
    child := Self.GetComponent(i);
    if 'image_' in child.getName() then
      Break;
    if i = hi then
    begin
      Self.LoadFromFile(path);
      Exit;
    end;
  end;

  TImage(child).LoadFromFile(path);
end;



type
  TDarkListBox = record
    OutterPanel: TPanel;
    InnerPanel: TPanel;
    ListBox: TListBox;
  end;

procedure TDarkListBox.Create(owner: TControl);
begin
  Self.OutterPanel.Create(owner);
  Self.OutterPanel.setBevelWidth(0);
  Self.OutterPanel.setColor($505050);

  Self.InnerPanel.Create(Self.OutterPanel);
  Self.InnerPanel.SetTop(2);
  Self.InnerPanel.SetLeft(2);
  Self.InnerPanel.setWidth(Self.OutterPanel.getWidth() - 4);
  Self.InnerPanel.setHeight(Self.OutterPanel.getHeight() - 4);
  Self.InnerPanel.setBevelWidth(0);
  Self.InnerPanel.setColor($303030);

  Self.ListBox.Create(Self.InnerPanel);
  Self.ListBox.setLeft(-2);
  Self.ListBox.SetTop(-2);
  Self.ListBox.setWidth(Self.OutterPanel.getWidth());
  Self.ListBox.setHeight(Self.OutterPanel.getHeight());

end;


function TDarkListBox.GetLeft(): Integer;
begin
  Result := Self.OutterPanel.GetLeft();
end;

function TDarkListBox.GetTop(): Integer;
begin
  Result := Self.OutterPanel.getTop();
end;

function TDarkListBox.GetWidth(): Integer;
begin
  Result := Self.OutterPanel.getWidth();
end;

function TDarkListBox.GetHeight(): Integer;
begin
  Result := Self.OutterPanel.getHeight();
end;


procedure TDarkListBox.SetLeft(value: Integer);
begin
  Self.OutterPanel.SetLeft(value);
end;

procedure TDarkListBox.SetTop(value: Integer);
begin
  Self.OutterPanel.SetTop(value);
end;

procedure TDarkListBox.SetWidth(value: Integer);
begin
  Self.OutterPanel.setWidth(value);
  Self.InnerPanel.setWidth(value - 4);
  Self.ListBox.setWidth(value);
end;

procedure TDarkListBox.SetHeight(value: Integer);
begin
  Self.OutterPanel.setHeight(value);
  Self.InnerPanel.setHeight(value - 4);
  Self.ListBox.setHeight(value);
end;


function TDarkListBox.GetAlign(): TAlign;
begin
  Result := Self.OutterPanel.getAlign();
end;

procedure TDarkListBox.SetAlign(value: TAlign);
var
  w, h: Int32;
begin
  Self.OutterPanel.setAlign(value);
  with TPanel(Self.OutterPanel.getOwner()) do
  begin
    w := GetWidth();
    h := getHeight();
  end;

  h -= TControl.AdjustToDPI(15);

  Self.InnerPanel.setWidth(w - TControl.AdjustToDPI(4));
  Self.InnerPanel.setHeight(h - TControl.AdjustToDPI(4));

  Self.ListBox.setWidth(w);
  Self.ListBox.setHeight(h);
end;



type
  TLabeledControl  = record Panel: TPanel; Caption: TLabel; Control: TControl; end;
  TLabeledEdit     = record(TLabeledControl) Edit: TEdit; end;
  TLabeledCheckBox = record(TLabeledControl) CheckBox: TCheckBox; end;
  TLabeledComboBox = record(TLabeledControl) ComboBox: TComboBox; end;
  TLabeledListBox  = record(TLabeledControl) ListBox: TListBox; end;
  TLabeledDarkListBox  = record(TLabeledControl) ListBox: TDarkListBox; end;

procedure TLabeledControl.Create(owner: TControl);
begin
  Self.Panel.Create(owner);
  Self.Panel.setBevelWidth(0);

  Self.Caption.Create(Self.Panel);
  Self.Caption.setAlign(alTop);
end;

procedure TLabeledEdit.Create(owner: TControl); override;
begin
  inherited;

  Self.Edit.Create(Self.Panel);
  Self.Edit.setAlign(alClient);
  Self.Edit.setHeight(TControl.AdjustToDPI(30));
  Self.Control := Self.Edit;

  Self.Panel.setHeight(Self.Caption.getHeight() + Self.Edit.getHeight());
end;

procedure TLabeledCheckBox.Create(owner: TControl); override;
  type TLabeledCheckBox = TLabeledCheckBox;
  procedure TLabeledCheckBox._PanelToggle(sender: TObject);
  var
    check: TCheckBox;
    event: TNotifyEvent;
  begin
    check := TPanel(sender).GetComponent(1);
    check.Toggle();

    event := check.GetOnChange();
    if event <> nil then
      Lapify(event)(check);
  end;

  procedure TLabeledCheckBox._LabelToggle(sender: TObject);
  begin
    Self._PanelToggle(TControl(sender).getParent());
  end;

begin
  Self.Panel.Create(owner);
  Self.Panel.setBevelWidth(0);
  Self.Panel.setOnClick(@Self._PanelToggle);

  Self.Caption.Create(Self.Panel);
  Self.Caption.setAlign(alLeft);
  Self.Caption.setOnClick(@Self._LabelToggle);

  Self.CheckBox.Create(Self.Panel);
  Self.CheckBox.setAlign(alLeft);
  Self.Control := Self.CheckBox;

  Self.Panel.setHeight(Self.Caption.GetTrueHeight());
  Self.Panel.setWidth(TControl.AdjustToDPI(22) + Self.Caption.GetTrueWidth());
end;

procedure TLabeledComboBox.Create(owner: TControl); override;
begin
  inherited;

  Self.ComboBox.Create(Self.Panel);
  Self.ComboBox.setAlign(alClient);
  Self.Control := Self.ComboBox;

  Self.Panel.setHeight(Self.Caption.getHeight() + Self.ComboBox.getHeight());
end;

procedure TLabeledListBox.Create(owner: TControl); override;
begin
  inherited;

  Self.ListBox.Create(Self.Panel);
  Self.ListBox.setAlign(alClient);
  Self.Control := Self.ListBox;

  Self.Panel.setHeight(Self.Caption.getHeight() + Self.ListBox.getHeight());
end;

procedure TLabeledDarkListBox.Create(owner: TControl); override;
begin
  inherited;

  Self.ListBox.Create(Self.Panel);
  Self.ListBox.setAlign(alClient);
  Self.Control := Self.ListBox.ListBox;

  Self.Panel.setHeight(Self.Caption.getHeight() + Self.ListBox.getHeight());
end;


procedure TLabeledControl.SetCaption(value: String);
begin
  Self.Caption.setCaption(value);
end;

procedure TLabeledCheckBox.SetCaption(value: String); override;
begin
  Self.Caption.setCaption(value);
  Self.Panel.setHeight(Self.Caption.GetTrueHeight());
  Self.Panel.setWidth(TControl.AdjustToDPI(22) + Self.Caption.GetTrueWidth());
end;


procedure TLabeledControl.SetColor(color: TColor);
begin
  Self.Panel.setColor(color);
end;

procedure TLabeledControl.SetControlColor(color: TColor);
begin
  Self.Control.setColor(color);
end;


procedure TLabeledControl.SetFontColor(color: TColor);
begin
  Self.Caption.SetFontColor(color);
end;

procedure TLabeledControl.SetControlFontColor(color: TColor);
begin
  Self.Control.SetFontColor(color);
end;

procedure TLabeledControl.SetFontSize(size: Int32);
begin
  Self.Caption.SetFontSize(size);
end;


procedure TLabeledControl.SetName(value: String);
var
  caption: String;
begin
  caption := Self.Panel.getCaption();
  Self.Panel.setName(value + '_panel');
  Self.Panel.setCaption(caption);

  caption := Self.Caption.getCaption();
  Self.Caption.setName(value + '_label');
  Self.Caption.setCaption(caption);
end;


procedure TLabeledEdit.SetName(value: String); override;
var
  caption: String;
begin
  value := LowerCase(StringReplace(LowerCase(value), ' ', '_', [rfReplaceAll]));

  inherited(value);
  caption := Self.Edit.getCaption();
  Self.Edit.setName(value + '_edit');
  Self.Edit.setCaption(caption);
end;

procedure TLabeledCheckBox.SetName(value: String); override;
var
  caption: String;
begin
  value := StringReplace(LowerCase(value), ' ', '_', [rfReplaceAll]);

  inherited(value);
  caption := Self.CheckBox.getCaption();
  Self.CheckBox.setName(value + '_checkbox');
  Self.CheckBox.setCaption(caption);
end;

procedure TLabeledComboBox.SetName(value: String); override;
var
  caption: String;
begin
  value := StringReplace(LowerCase(value), ' ', '_', [rfReplaceAll]);

  inherited(value);
  caption := Self.ComboBox.getCaption();
  Self.ComboBox.setName(value + '_combobox');
  Self.ComboBox.setCaption(caption);
end;

procedure TLabeledListBox.SetName(value: String); override;
var
  caption: String;
begin
  value := StringReplace(LowerCase(value), ' ', '_', [rfReplaceAll]);

  inherited(value);
  caption := Self.ListBox.getCaption();
  Self.ListBox.setName(value + '_listbox');
  Self.ListBox.setCaption(caption);
end;

procedure TLabeledDarkListBox.SetName(value: String); override;
var
  caption: String;
begin
  value := StringReplace(LowerCase(value), ' ', '_', [rfReplaceAll]);

  inherited(value);
  caption := Self.ListBox.ListBox.getCaption();
  Self.ListBox.ListBox.setName(value + '_listbox');
  Self.ListBox.ListBox.setCaption(caption);
end;


procedure TLabeledControl.SetLeft(value: Int32);
begin
  Self.Panel.setLeft(value);
end;

procedure TLabeledControl.SetTop(value: Int32);
begin
  Self.Panel.SetTop(value);
end;


procedure TLabeledControl.SetWidth(value: Int32);
begin
  Self.Panel.setWidth(value);
end;

procedure TLabeledDarkListBox.SetWidth(value: Int32); override;
begin
  Self.Panel.setWidth(value);
  Self.ListBox.SetAlign(Self.ListBox.GetAlign());
end;


procedure TLabeledControl.SetHeight(value: Int32);
begin
  Self.Panel.setHeight(value);
end;

procedure TLabeledDarkListBox.SetHeight(value: Int32); override;
begin
  Self.Panel.setHeight(value);
  Self.ListBox.SetAlign(Self.ListBox.GetAlign());
end;


procedure TLabeledControl.SetAlign(value: TAlign);
begin
  Self.Panel.setAlign(value);
end;

procedure TLabeledCheckBox.SetAlign(value: TAlign); override;
begin
  Self.Panel.setAlign(value);
end;


procedure TLabeledControl.SetVisible(value: Boolean);
begin
  Self.Panel.setVisible(value);
end;


function TLabeledControl.GetLeft(): Int32;
begin
  Result := Self.Panel.getLeft();
end;

function TLabeledControl.GetTop(): Int32;
begin
  Result := Self.Panel.getTop();
end;

function TLabeledControl.GetRight(): Int32;
begin
  Result := Self.Panel.getBoundsRect().Right;
end;

function TLabeledControl.GetBottom(): Int32;
begin
  Result := Self.Panel.getBoundsRect().Bottom;
end;


function TLabeledControl.GetWidth(): Int32;
begin
  Result := Self.Panel.getWidth();
end;

function TLabeledControl.GetHeight(): Int32;
begin
  Result := Self.Panel.getHeight();
end;


function TLabeledControl.GetVisible(): Boolean;
begin
  Result := Self.Panel.GetVisible();
end;


procedure TLabeledEdit.SetText(value: String);
begin
  Self.Edit.setText(value);
end;

procedure TLabeledComboBox.SetText(value: String);
begin
  Self.ComboBox.setText(value);
end;


function TLabeledEdit.GetText(): String;
begin
  Result := Self.Edit.GetText();
end;

function TLabeledComboBox.GetText(): String;
begin
  Result := Self.ComboBox.GetText();
end;

function TLabeledListBox.GetText(): String;
begin
  Result := Self.ListBox.GetSelectedText();
end;


procedure TLabeledEdit.Clear();
begin
  Self.Edit.Clear();
end;

procedure TLabeledComboBox.Clear();
begin
  Self.ComboBox.Clear();
end;

procedure TLabeledListBox.Clear();
begin
  Self.ListBox.Clear();
end;


procedure TLabeledCheckBox.SetChecked(value: Boolean);
begin
  Self.CheckBox.SetChecked(value);
end;


function TLabeledCheckBox.IsChecked(): Boolean;
begin
  Result := Self.CheckBox.IsChecked();
end;

function TLabeledCheckBox.GetState(): TCheckBoxState;
begin
  Result := Self.CheckBox.getState();
end;

procedure TLabeledEdit.SetEnabled(value: Boolean);
begin
  Self.Edit.setEnabled(value);
end;

procedure TLabeledCheckBox.SetEnabled(value: Boolean);
begin
  Self.Panel.setEnabled(value);
  Self.Caption.setEnabled(value);
  Self.CheckBox.setEnabled(value);
end;

procedure TLabeledComboBox.SetEnabled(value: Boolean);
begin
  Self.ComboBox.setEnabled(value);
end;

procedure TLabeledListBox.SetEnabled(value: Boolean);
begin
  Self.ListBox.setEnabled(value);
end;


procedure TLabeledEdit.SetPasswordChar(value: Char = '*');
begin
  Self.Edit.setPasswordChar(value);
end;


procedure TLabeledComboBox.SetStyle(value: TComboBoxStyle);
begin
  Self.ComboBox.setStyle(value);
end;

procedure TLabeledListBox.SetStyle(value: TListBoxStyle);
begin
  Self.ListBox.setStyle(value);
end;


procedure TLabeledCombobox.AddItem(value: String);
begin
  Self.ComboBox.getItems().Add(value);
end;

procedure TLabeledListBox.AddItem(value: String);
begin
  Self.ListBox.getItems().Add(value);
end;


procedure TLabeledCombobox.AddItemArray(valueArray: TStringArray);
var
  value: String;
begin
  for value in valueArray do
    Self.AddItem(value);
end;

procedure TLabeledListBox.AddItemArray(valueArray: TStringArray);
var
  value: String;
begin
  for value in valueArray do
    Self.AddItem(value);
end;


procedure TLabeledCombobox.SetItemIndex(value: Int32);
begin
  Self.ComboBox.setItemIndex(value);
end;

procedure TLabeledListBox.SetItemIndex(value: Int32);
begin
  Self.ListBox.setItemIndex(value);
end;


function TLabeledCombobox.GetItemIndex(): Int32;
begin
  Result := Self.ComboBox.getItemIndex();
end;

function TLabeledListBox.GetItemIndex(): Int32;
begin
  Result := Self.ListBox.getItemIndex();
end;



{$IFNDEF WS_UPDATER_INCLUDED}      
{$DEFINE WS_UPDATER_INCLUDED}


type
  TScriptFile = record
    URL: String;
    ID: String;
    Revision: Int32;
    Path: String;
  end;

  TScriptFileArray = array of TScriptFile;

  TWaspUpdater = record
    Name: String;
    Launcher: TScriptFile;

    Scripts: TScriptFileArray;
    ScriptsPath: String;

    MonitorSRLT: TMonitor;
    MonitorWL: TMonitor;

    UpdateAfterLogin: Boolean;
  end;

var
  WaspUpdater: TWaspUpdater;

procedure TMonitor.NextState(); forward;

procedure TMonitor._OnTimer(sender: TObject);
var
  fileName: String;
begin
  fileName := WaspAsync.Path + Self.CurrentFile;

  if FileExists(fileName) and DeleteFile(fileName) then
  begin
    TTimer(sender).SetEnabled(False);
    Self.NextState();
  end;
end;

procedure TMonitor.NextState();
var
  params: TStringArray;
begin
  Self.State := EMonitorState(Ord(Self.State) + 1);
  if Self.State > High(EMonitorState) then
    Self.State := EMonitorState.NONE;

  case Self.State of
    EMonitorState.DOWNLOAD:
    begin
      Self.CurrentFile := 'downloader-' + LowerCase(Self.Package) + '.done';
      GitHubClient.Download(Self.Package);

      Self.Caption.setCaption('Downloading');
      Self.Caption.SetFontColor($00CCFF);
      Self.Caption.Repaint();
      Self.Button.setEnabled(False);

      Self.Timer.SetEnabled(True);
    end;

    EMonitorState.UNZIP:
    begin
      Self.CurrentFile := 'unzipper-' + LowerCase(Self.Package) + '.done';
      params := ['path=' + GitHubClient.DownloadPath, 'name=' + Self.Package];
      WaspAsync.Run('unzipper', params);

      Self.Caption.setCaption('Unzipping');
      Self.Caption.SetFontColor($00CCAA);
      Self.Caption.Repaint();

      Self.Timer.SetEnabled(True);
    end;

    EMonitorState.CLEAN:
    begin
      Self.CurrentFile := 'mover-' + LowerCase(Self.Package) + '.done';
      params := ['origin=' + GitHubClient.DownloadPath, 'pkg=' + Self.Package];
      WaspAsync.Run('mover', params);

      Self.Caption.setCaption('Cleaning');
      Self.Caption.SetFontColor($00CCAA);
      Self.Caption.Repaint();

      Self.Timer.SetEnabled(True);
    end;

    EMonitorState.NONE:
    begin
      Self.CurrentFile := '';

      case LowerCase(Self.Package) of
        'srl-t', 'srlt':
        begin
          GitHubClient.Packages.Current.SRLT := GitHubClient.GetCurrentPackageVersion('srl-t');
          if GitHubClient.Packages.Current.SRLT = '' then
            Self.Caption.setCaption('Missing')
          else
            Self.Caption.setCaption('v.' + GitHubClient.Packages.Current.SRLT);

          if GitHubClient.Packages.Current.SRLT <> GitHubClient.Packages.Latest.SRLT then
            Self.Caption.SetFontColor($1800E9)
          else
            Self.Caption.SetFontColor($18E982);
          Self.Caption.Repaint();
        end;
        'wasplib', 'wl':
        begin
          GitHubClient.Packages.Current.WaspLib := GitHubClient.GetCurrentPackageVersion('wasplib');
          if GitHubClient.Packages.Current.WaspLib = '' then
            Self.Caption.setCaption('Missing')
          else
            Self.Caption.setCaption('v.' + GitHubClient.Packages.Current.WaspLib);

          if GitHubClient.Packages.Current.WaspLib <> GitHubClient.Packages.Latest.WaspLib then
            Self.Caption.SetFontColor($1800E9)
          else
            Self.Caption.SetFontColor($18E982);
          Self.Caption.Repaint();
        end;
      end;

      Self.Caption.Repaint();
      Self.Button.setEnabled(True);
      Self.Timer.setEnabled(False);
    end;
  end;
end;

procedure TMonitor.RunMonitor(caption, button: TComponent);
begin
  if not Self.IsSetup then
  begin
    Self.Caption := caption;
    Self.Button := button;
    Self.Timer.setOnTimer(@Self._OnTimer);
    Self.IsSetup := True;
  end;

  Self.NextState();
end;


procedure TWaspUpdater.Update(pkg: String; caption, button: TComponent);
begin
  case pkg of
    'srlt':    Self.MonitorSRLT.RunMonitor(caption, button);
    'wasplib': Self.MonitorWL.RunMonitor(caption, button);
  end;
end;


function TWaspUpdater.GetScriptFileEx(filepath: String): TScriptFile;
var
  url, id, fileContent: String;
  tmp: String;
begin
  Result.URL := ExtractFileName(filepath).Before('.simba');
  Result.Path := filepath;
  fileContent := ReadFileContents(filepath);
  Result.ID := fileContent.After('SCRIPT_ID := ''').Before('''}');
  Result.Revision := StrToIntDef(fileContent.After('SCRIPT_REVISION := ''').Before('''}'), 0);
end;

function TWaspUpdater.GetScriptFiles(): TScriptFileArray;
var
  files: TStringArray;
  i: Int32;
  script: TScriptFile;
begin
  if Self.Scripts <> [] then Exit(Self.Scripts);

  files := GetFiles(Self.ScriptsPath, 'simba');
  for i := 0 to High(files) do
  begin
    script := GetScriptFileEx(Self.ScriptsPath + files[i]);
    if script <> [] then Result += script;
  end;

  Self.Scripts := Result;
end;

function TWaspUpdater.GetScriptFile(id: String): TScriptFile;
var
  i: Int32;
  scripts: TScriptFileArray;
begin
  scripts := Self.GetScriptFiles();
  for i := 0 to High(scripts) do
    if id = scripts[i].ID then
      Exit(scripts[i]);
end;

procedure TWaspUpdater.UpdateScriptFileRevision(script: TScriptFile);
var
  i: Int32;
begin
  for i := 0 to High(Self.Scripts) do
    if Self.Scripts[i].ID = script.ID then
    begin
      Self.Scripts[i] := script;
      Exit;
    end;

  Self.Scripts += script;
end;

procedure TWaspUpdater.UpdateScript(script: TScriptData);
var
  files: TStringArray;
  fileName, path: String;
begin
  files := GetFiles(WaspClient.DownloadPath, 'simba');

  for fileName in files do
    DeleteFile(WaspClient.DownloadPath + fileName);

  WaspClient.DownloadScript(script.URL, script.ID, script.Revision);

  files := GetFiles(WaspClient.DownloadPath, 'simba');
  if Length(files) <> 1 then Exit;

  fileName := files[0];
  path := Self.ScriptsPath + fileName;
  if FileExists(path) and not DeleteFile(path) then
    TerminateScript('Failed to delete old script: ' + fileName);

  if not RenameFile(WaspClient.DownloadPath + fileName, path) then
  begin
    DeleteFile(WaspClient.DownloadPath + fileName);
    TerminateScript('Failed to move script: ' + fileName);
  end;

  Self.UpdateScriptFileRevision(Self.GetScriptFileEx(path));
end;


function TWaspUpdater.GetProfileFileString(): String;
begin
  Result := 'statusbars.rightBarMode=PRAYER' + LineEnding +
            'worldhopper.worldTypeFilter=[]' + LineEnding +
            'chatfilter.filterGameChat=false' + LineEnding +
            'grounditems.textOutline=false' + LineEnding +
            'runelite.crowdsourcingplugin=false' + LineEnding +
            'implings.showmagpie=NONE' + LineEnding +
            'interacthighlight.objectHoverHighlightColor=-1878982657' + LineEnding +
            'fishing.statTimeout=5' + LineEnding +
            'groundMarker.markerColor=-256' + LineEnding +
            'banktags.useTabs=true' + LineEnding +
            'worldhopper.subscriptionFilter=BOTH' + LineEnding +
            'worldmap.minigameTooltip=true' + LineEnding +
            'itemCharge.showWaterskinCharges=true' + LineEnding +
            'music.musicVolume=0' + LineEnding +
            'runelite.trayIcon=true' + LineEnding +
            'runelite.combatlevelplugin=false' + LineEnding +
            'chatcommands.bh=true' + LineEnding +
            'grandexchange.quickLookup=true' + LineEnding +
            'boosts.compactDisplay=false' + LineEnding +
            'hunterplugin.hexColorEmptyTrap=-65536' + LineEnding +
            'runelite.hiscoreplugin=false' + LineEnding +
            'screenshot.notifyWhenTaken=true' + LineEnding +
            'groundMarker.drawOnMinimap=false' + LineEnding +
            'runecraft.showFire=true' + LineEnding +
            'idlenotifier.specNotification={"enabled"\:false,"initialized"\:false,"override"\:false,"tray"\:false,"volume"\:0,"timeout"\:0,"gameMessage"\:false,"sendWhenFocused"\:false}' + LineEnding +
            'poh.showRepairStand=true' + LineEnding +
            'statusbars.hideAfterCombatDelay=0' + LineEnding +
            'grandexchange.enableNotifications={"enabled"\:true,"initialized"\:false,"override"\:false,"tray"\:false,"volume"\:0,"timeout"\:0,"gameMessage"\:false,"sendWhenFocused"\:false}' + LineEnding +
            'agility.markHighlight=-65536' + LineEnding +
            'xpglobes.showXpHour=true' + LineEnding +
            'grounditems.deprioritizeHiddenItems=false' + LineEnding +
            'timers.showTzhaarTimers=true' + LineEnding +
            'fpscontrol.limitFpsUnfocused=false' + LineEnding +
            'xpglobes.Progress\ arc\ width=2' + LineEnding +
            'runecraft.showAir=true' + LineEnding +
            'party.sounds=true' + LineEnding +
            'wintertodt.notifyCold=INTERRUPT' + LineEnding +
            'itemCharge.showAmuletOfChemistryCharges=true' + LineEnding +
            'music.soundEffectVolume=0' + LineEnding +
            'grounditems.notifyHighlightedDrops=false' + LineEnding +
            'raids.layoutMessage=false' + LineEnding +
            'runelite.runenergyplugin=false' + LineEnding +
            'driftnet.showNetStatus=true' + LineEnding +
            'nightmareZone.absorptionnotification={"enabled"\:true,"initialized"\:false,"override"\:false,"tray"\:false,"volume"\:0,"timeout"\:0,"gameMessage"\:false,"sendWhenFocused"\:false}' + LineEnding +
            'corp.leftClickCore=true' + LineEnding +
            'screenshot.ccKick=false' + LineEnding +
            'xpdrop.meleePrayerColor=-15368019' + LineEnding +
            'screenshot.playerDeath=false' + LineEnding +
            'entityhider.hideProjectiles=false' + LineEnding +
            'runelite.instancemapplugin=false' + LineEnding +
            'runelite.questlistplugin=false' + LineEnding +
            'idlenotifier.highEnergyNotification={"enabled"\:false,"initialized"\:false,"override"\:false,"tray"\:false,"volume"\:0,"timeout"\:0,"gameMessage"\:false,"sendWhenFocused"\:false}' + LineEnding +
            'itemCharge.showBraceletOfSlaughterCharges=true' + LineEnding +
            'chatfilter.collapseGameChat=false' + LineEnding +
            'screenshot.includeFrame=true' + LineEnding +
            'randomevents.notifyMoM={"enabled"\:false,"initialized"\:false,"override"\:false,"tray"\:false,"volume"\:0,"timeout"\:0,"gameMessage"\:false,"sendWhenFocused"\:false}' + LineEnding +
            'runelite.opponentinfoplugin=false' + LineEnding +
            'music.granularSliders=true' + LineEnding +
            'kingdomofmiscellania.cofferThreshold=7500000' + LineEnding +
            'runelite.notificationRequestFocus=OFF' + LineEnding +
            'screenshot.combatAchievements=true' + LineEnding +
            'teamCapes.minimumCapeCount=1' + LineEnding +
            'idlenotifier.oxygen=1' + LineEnding +
            'boosts.notifyOnBoost={"enabled"\:true,"initialized"\:false,"override"\:false,"tray"\:false,"volume"\:0,"timeout"\:0,"gameMessage"\:false,"sendWhenFocused"\:false}' + LineEnding +
            'implings.magpieColor=-7434733' + LineEnding +
            'objectindicators.highlightTile=false' + LineEnding +
            'party.statusOverlayPrayer=false' + LineEnding +
            'entityhider.hideClanMates=false' + LineEnding +
            'menuentryswapper.swapQuick=true' + LineEnding +
            'runecraft.showNature=true' + LineEnding +
            'discord.showMainMenu=true' + LineEnding +
            'playerindicators.highlightClanMembers=ENABLED' + LineEnding +
            'runecraft.hightlightDarkMage=true' + LineEnding +
            'menuentryswapper.shiftClickCustomization=true' + LineEnding +
            'tearsofguthix.blueTearsColor=1677787135' + LineEnding +
            'runelite.examineplugin=false' + LineEnding +
            'chatcommands.lms=true' + LineEnding +
            'menuentryswapper.swapTemporossLeave=false' + LineEnding +
            'tileindicators.destinationTileBorderWidth=2.0' + LineEnding +
            'grounditems.defaultColor=-1' + LineEnding +
            'worldmap.fairyRingTooltips=true' + LineEnding +
            'idlenotifier.hitpointsNotification={"enabled"\:false,"initialized"\:false,"override"\:false,"tray"\:false,"volume"\:0,"timeout"\:0,"gameMessage"\:false,"sendWhenFocused"\:false}' + LineEnding +
            'metronome.tickVolume=96' + LineEnding +
            'prayer.prayerBarHideIfNotPraying=true' + LineEnding +
            'worldmap.runecraftingAltarIcon=true' + LineEnding +
            'entityhider.hidePlayers=true' + LineEnding +
            'runecraft.showSoul=true' + LineEnding +
            'timers.showSpellbookSwap=true' + LineEnding +
            'motherlode.showOresFound=true' + LineEnding +
            'clanchat.privateMessageIcons=false' + LineEnding +
            'textrecolor.opaquePrivateMessageReceivedHighlight=-16767101' + LineEnding +
            'chatfilter.filterClan=false' + LineEnding +
            'xpTracker.progressBarTooltipLabel=TIME_TO_LEVEL' + LineEnding +
            'gpu.uiScalingMode=LINEAR' + LineEnding +
            'grounditems.hotkey=0\:512' + LineEnding +
            'chatcommands.gc=true' + LineEnding +
            'woodcutting.showRedwoods=true' + LineEnding +
            'runelite.grounditemsplugin=false' + LineEnding +
            'runelite.timetrackingplugin=false' + LineEnding +
            'grounditems.menuHighlightMode=NAME' + LineEnding +
            'menuentryswapper.teleportSubmenus=false' + LineEnding +
            'entityhider.hideLocalPlayer=false' + LineEnding +
            'tileindicators.highlightCurrentColor=-16711681' + LineEnding +
            'entityhider.hideNPCs2D=false' + LineEnding +
            'cannon.showEmptyCannonNotification={"enabled"\:true,"initialized"\:false,"override"\:false,"tray"\:false,"volume"\:0,"timeout"\:0,"gameMessage"\:false,"sendWhenFocused"\:false}' + LineEnding +
            'itemidentification.showAllotmentSeeds=false' + LineEnding +
            'pyramidplunder.highlightUrnsFloor=9' + LineEnding +
            'timers.showBlessedCrystalScarab=true' + LineEnding +
            'screenshot.valuableDrop=false' + LineEnding +
            'zoom.invertYaw=false' + LineEnding +
            'discord.showSkillActivity=true' + LineEnding +
            'statusbars.barWidth=20' + LineEnding +
            'worldmap.miningSiteTooltips=true' + LineEnding +
            'menuentryswapper.swapHerbs=false' + LineEnding +
            'itemstat.absolute=true' + LineEnding +
            'idlenotifier.lowEnergyNotification={"enabled"\:false,"initialized"\:false,"override"\:false,"tray"\:false,"volume"\:0,"timeout"\:0,"gameMessage"\:false,"sendWhenFocused"\:false}' + LineEnding +
            'screenshot.collectionLogEntries=true' + LineEnding +
            'itemstat.colorBetterUncapped=-13373901' + LineEnding +
            'screenshot.kills=false' + LineEnding +
            'menuentryswapper.bankDepositShiftClick=OFF' + LineEnding +
            'implings.earthColor=-12691904' + LineEnding +
            'runelite.bosstimersplugin=false' + LineEnding +
            'xpglobes.Orb\ duration=10' + LineEnding +
            'textrecolor.transparentClanMessageHighlight=-1' + LineEnding +
            'party.statusOverlayVeng=true' + LineEnding +
            'zoom.rightClickMovesCamera=false' + LineEnding +
            'menuentryswapper.swapGEItemCollect=DEFAULT' + LineEnding +
            'menuentryswapper.swapBait=false' + LineEnding +
            'groundMarker.showImportExport=true' + LineEnding +
            'attackIndicator.warnForStrength=false' + LineEnding +
            'itemidentification.showBerrySeeds=false' + LineEnding +
            'runelite.tearsofguthixplugin=false' + LineEnding +
            'runelite.smeltingplugin=false' + LineEnding +
            'npcindicators.fillColor=335609855' + LineEnding +
            'itemCharge.veryLowWarningColor=-65536' + LineEnding +
            'runecraft.showLaw=true' + LineEnding +
            'herbiboar.showClickboxes=false' + LineEnding +
            'runelite.fishingplugin=false' + LineEnding +
            'itemCharge.braceletOfClayNotification={"enabled"\:true,"initialized"\:false,"override"\:false,"tray"\:false,"volume"\:0,"timeout"\:0,"gameMessage"\:false,"sendWhenFocused"\:false}' + LineEnding +
            'timers.showAntiFire=true' + LineEnding +
            'defaultworld.useLastWorld=false' + LineEnding +
            'attackIndicator.warnForDefensive=false' + LineEnding +
            'chatnotification.notifyOnPM={"enabled"\:false,"initialized"\:false,"override"\:false,"tray"\:false,"volume"\:0,"timeout"\:0,"gameMessage"\:false,"sendWhenFocused"\:false}' + LineEnding +
            'itemidentification.showPlanks=false' + LineEnding +
            'woodcutting.showNestNotification={"enabled"\:true,"initialized"\:false,"override"\:false,"tray"\:false,"volume"\:0,"timeout"\:0,"gameMessage"\:false,"sendWhenFocused"\:false}' + LineEnding +
            'implings.showname=false' + LineEnding +
            'slayer.weaknessPrompt=true' + LineEnding +
            'attackIndicator.warnForMagic=false' + LineEnding +
            'mousehighlight.uiTooltip=true' + LineEnding +
            'fishing.flyingFishNotification={"enabled"\:true,"initialized"\:false,"override"\:false,"tray"\:false,"volume"\:0,"timeout"\:0,"gameMessage"\:false,"sendWhenFocused"\:false}' + LineEnding +
            'music.muteOwnAreaSounds=false' + LineEnding +
            'chathistory.clearHistory=true' + LineEnding +
            'textrecolor.transparentClanChatGuestMessageHighlight=-1' + LineEnding +
            'menuentryswapper.objectLeftClickCustomization=true' + LineEnding +
            'attackIndicator.warnForRanged=false' + LineEnding +
            'grounditems.showHighlightedOnly=false' + LineEnding +
            'itemidentification.showPyreLogs=false' + LineEnding +
            'xpTracker.wiseOldManOpenOption=true' + LineEnding +
            'party.recolorNames=true' + LineEnding +
            'agility.highlightPortals=true' + LineEnding +
            'gpu.expandedMapLoadingChunks=3' + LineEnding +
            'roofremoval.removePosition=true' + LineEnding +
            'driftnet.untaggedFishColor=-16711681' + LineEnding +
            'combatlevel.wildernessAttackLevelRange=true' + LineEnding +
            'runelite.worldmapplugin=false' + LineEnding +
            'groundMarker.fillOpacity=50' + LineEnding +
            'blastmine.hexWarningColor=-2542080' + LineEnding +
            'timers.showFarmersAffinity=true' + LineEnding +
            'screenshot.hotkey=0\:0' + LineEnding +
            'poh.showXericsTalisman=true' + LineEnding +
            'runelite.barrowsplugin=false' + LineEnding +
            'worldmap.miscellaneousTeleportIcon=true' + LineEnding +
            'menuentryswapper.swapJewelleryBox=false' + LineEnding +
            'npcUnaggroArea.npcUnaggroAreaColor=-256' + LineEnding +
            'worldhopper.showSidebar=true' + LineEnding +
            'prayer.prayerFlickColor=-16711681' + LineEnding +
            'runelite.barbarianassaultplugin=false' + LineEnding +
            'dpscounter.showDamage=false' + LineEnding +
            'gpu.fpsTarget=60' + LineEnding +
            'idlenotifier.spec=1' + LineEnding +
            'runelite.chatcommandsplugin=false' + LineEnding +
            'wintertodt.showOverlay=true' + LineEnding +
            'runelite.musicplugin=false' + LineEnding +
            'blastfurnace.showConveyorBelt=false' + LineEnding +
            'timers.showCannon=true' + LineEnding +
            'menuentryswapper.bankWithdrawShiftClick=OFF' + LineEnding +
            'herbiboar.showTrail=true' + LineEnding +
            'runelite.raidsplugin=false' + LineEnding +
            'timers.showPickpocketStun=true' + LineEnding +
            'bank.blockJagexAccountAd=false' + LineEnding +
            'prayer.showPrayerDoseIndicator=true' + LineEnding +
            'grounditems.notifyTier=OFF' + LineEnding +
            'xpglobes.Orb\ size=40' + LineEnding +
            'timetracking.activeTab=CLOCK' + LineEnding +
            'grounditems.recolorMenuHiddenItems=false' + LineEnding +
            'menuentryswapper.swapMorytaniaLegs=WEAR' + LineEnding +
            'itemstat.colorNoChange=-1118482' + LineEnding +
            'wintertodt.notifyBrazierOut=true' + LineEnding +
            'blastmine.showTimerOverlay=true' + LineEnding +
            'motherlode.showMiningStats=true' + LineEnding +
            'nightmareZone.moveoverlay=true' + LineEnding +
            'music.muteOtherAreaEnvironmentSounds=false' + LineEnding +
            'dailytaskindicators.showStaves=true' + LineEnding +
            'npcindicators.highlightOutline=false' + LineEnding +
            'runelite.groundmarkerplugin=false' + LineEnding +
            'implings.crystalColor=-10634030' + LineEnding +
            'music.muteOtherAreaSounds=false' + LineEnding +
            'inventorytags.fillOpacity=50' + LineEnding +
            'interfaceStyles.hdMenu=false' + LineEnding +
            'runelite.ammoplugin=false' + LineEnding +
            'gpu.smoothBanding=true' + LineEnding +
            'xpglobes.showVirtualLevel=false' + LineEnding +
            'grounditems.highlightValueCalculation=HIGHEST' + LineEnding +
            'screenshot.displayDate=true' + LineEnding +
            'textrecolor.transparentPublicChatHighlight=-1' + LineEnding +
            'interfaceStyles.hdHealthBars=false' + LineEnding +
            'chatcommands.duels=true' + LineEnding +
            'roofremoval.overridePOH=false' + LineEnding +
            'runelite.wintertodtplugin=false' + LineEnding +
            'grounditems.dontHideUntradeables=true' + LineEnding +
            'hunterplugin.hexColorOpenTrap=-256' + LineEnding +
            'xpglobes.enableTooltips=true' + LineEnding +
            'randomevents.notifyQuiz={"enabled"\:false,"initialized"\:false,"override"\:false,"tray"\:false,"volume"\:0,"timeout"\:0,"gameMessage"\:false,"sendWhenFocused"\:false}' + LineEnding +
            'runelite.fairyringplugin=false' + LineEnding +
            'runelite.notificationFocused=false' + LineEnding +
            'poh.showSpellbook=true' + LineEnding +
            'itemCharge.showBellowCharges=true' + LineEnding +
            'inventoryViewer.toggleKeybind=0\:0' + LineEnding +
            'loottracker.npcKillChatMessage=false' + LineEnding +
            'itemCharge.showBindingNecklaceCharges=true' + LineEnding +
            'interacthighlight.npcAttackHoverHighlightColor=-1862271232' + LineEnding +
            'menuentryswapper.swapHarpoon=false' + LineEnding +
            'gpu.brightTextures=false' + LineEnding +
            'stretchedmode.integerScaling=false' + LineEnding +
            'woodcutting.forestryEnchantmentRitualNotification={"enabled"\:true,"initialized"\:false,"override"\:false,"tray"\:false,"volume"\:0,"timeout"\:0,"gameMessage"\:false,"sendWhenFocused"\:false}' + LineEnding +
            'runelite.fontType=SMALL' + LineEnding +
            'kourendLibrary.showTargetHintArrow=true' + LineEnding +
            'mining.statTimeout=5' + LineEnding +
            'specialcounter.bulwarkThreshold=0' + LineEnding +
            'chatcommands.price=true' + LineEnding +
            'keyremapping.f10=48\:0' + LineEnding +
            'keyremapping.f12=61\:0' + LineEnding +
            'textrecolor.transparentPrivateMessageReceivedHighlight=-1' + LineEnding +
            'keyremapping.f11=45\:0' + LineEnding +
            'grounditems.showLootbeamForHighlighted=false' + LineEnding +
            'menuentryswapper.swapBanker=true' + LineEnding +
            'objectindicators.markerColor=-256' + LineEnding +
            'worldhopper.quickhopOutOfDanger=true' + LineEnding +
            'tileindicators.destinationTileFillColor=838860800' + LineEnding +
            'worldmap.arceuusSpellbookIcon=true' + LineEnding +
            'chatcommands.lvl=true' + LineEnding +
            'fishing.overlayColor=-16711681' + LineEnding +
            'specialcounter.infobox=true' + LineEnding +
            'timers.showVengeance=true' + LineEnding +
            'timers.showMenaphiteRemedy=true' + LineEnding +
            'corp.showDamage=true' + LineEnding +
            'playerindicators.nonClanMemberColor=-65536' + LineEnding +
            'boosts.relativeBoost=false' + LineEnding +
            'blastmine.showRockIconOverlay=true' + LineEnding +
            'worldmap.agilityShortcutIcon=true' + LineEnding +
            'screenshot.rewards=true' + LineEnding +
            'xpTracker.skillTabOverlayMenuOptions=true' + LineEnding +
            'grounditems.collapseEntries=false' + LineEnding +
            'motherlode.showBrokenStruts=true' + LineEnding +
            'poh.showPortals=true' + LineEnding +
            'inventorytags.tagUnderline=false' + LineEnding +
            'motherlode.showMiningState=true' + LineEnding +
            'raids.screenshotHotkey=0\:0' + LineEnding +
            'worldmap.hunterAreaTooltips=true' + LineEnding +
            'blastmine.hexTimerColor=-2542080' + LineEnding +
            'menuentryswapper.npcShiftClickWalkHere=false' + LineEnding +
            'xpglobes.enableCustomArcColor=false' + LineEnding +
            'runelite.friendlistplugin=false' + LineEnding +
            'npcindicators.ignorePets=true' + LineEnding +
            'woodcutting.highlightGlowingRoots=true' + LineEnding +
            'attackIndicator.alwaysShowStyle=true' + LineEnding +
            'dailytaskindicators.showEssence=false' + LineEnding +
            'itemidentification.showGems=false' + LineEnding +
            'runelite.xpdropplugin=false' + LineEnding +
            'playerindicators.highlightSelf=DISABLED' + LineEnding +
            'fpscontrol.maxFpsUnfocused=50' + LineEnding +
            'cooking.fermentTimer=true' + LineEnding +
            'runenergy.ringOfEnduranceChargeMessage=true' + LineEnding +
            'woodcutting.forestryFriendlyEntNotification={"enabled"\:true,"initialized"\:false,"override"\:false,"tray"\:false,"volume"\:0,"timeout"\:0,"gameMessage"\:false,"sendWhenFocused"\:false}' + LineEnding +
            'tileindicators.highlightDestinationColor=-8355712' + LineEnding +
            'dailytaskindicators.showRunes=false' + LineEnding +
            'npcindicators.highlightSouthWestTrueTile=false' + LineEnding +
            'kourendLibrary.showTutorialOverlay=true' + LineEnding +
            'wintertodt.notifySnowfall=INTERRUPT' + LineEnding +
            'mining.showMiningStats=true' + LineEnding +
            'timetracking.sortOrder=NONE' + LineEnding +
            'textrecolor.opaqueClanGuestInfoHighlight=-65536' + LineEnding +
            'runelite.interfaceFontType=REGULAR' + LineEnding +
            'runelite.boostsplugin=false' + LineEnding +
            'itemstat.colorWorse=-1166541' + LineEnding +
            'fishing.harpoonfishOverlayColor=-16711936' + LineEnding +
            'implings.youngColor=-5266296' + LineEnding +
            'interfaceStyles.rsCrossSprites=false' + LineEnding +
            'randomevents.notifyTurpentine={"enabled"\:false,"initialized"\:false,"override"\:false,"tray"\:false,"volume"\:0,"timeout"\:0,"gameMessage"\:false,"sendWhenFocused"\:false}' + LineEnding +
            'runelite.infoboxFontType=REGULAR' + LineEnding +
            'menuentryswapper.swapDesertAmulet=WEAR' + LineEnding +
            'playerindicators.highlightFriends=ENABLED' + LineEnding +
            'worldmap.standardSpellbookIcon=true' + LineEnding +
            'chatfilter.collapsePlayerChat=false' + LineEnding +
            'grandexchange.highlightSearchMatch=true' + LineEnding +
            'interacthighlight.npcShowInteract=true' + LineEnding +
            'playerindicators.highlightFriendsChat=ENABLED' + LineEnding +
            'xpdrop.fakeXpDropDelay=0' + LineEnding +
            'pyramidplunder.highlightDoors=true' + LineEnding +
            'timers.showImbuedHeart=true' + LineEnding +
            'slayer.targetColor=-65536' + LineEnding +
            'itemprices.showGEPrice=true' + LineEnding +
            'gpu.fogDepth=0' + LineEnding +
            'chatfilter.filterClanChat=false' + LineEnding +
            'pyramidplunder.showExactTimer=true' + LineEnding +
            'clanchat.showJoinLeave=false' + LineEnding +
            'agility.highlightSepulchreNpcs=true' + LineEnding +
            'timers.showHealGroup=true' + LineEnding +
            'regenmeter.showSpecial=true' + LineEnding +
            'itemCharge.showDodgyCount=true' + LineEnding +
            'mousehighlight.chatboxTooltip=true' + LineEnding +
            'worldmap.fairyRingIcon=true' + LineEnding +
            'keyremapping.esc=27\:0' + LineEnding +
            'roofremoval.removeBetween=true' + LineEnding +
            'keyremapping.left=65\:0' + LineEnding +
            'party.pings=true' + LineEnding +
            'xpupdater.runetracker=false' + LineEnding +
            'randomevents.notifyDemon={"enabled"\:false,"initialized"\:false,"override"\:false,"tray"\:false,"volume"\:0,"timeout"\:0,"gameMessage"\:false,"sendWhenFocused"\:false}' + LineEnding +
            'bank.rightClickBankInventory=false' + LineEnding +
            'barrows.showPrayerDrainTimer=true' + LineEnding +
            'chathistory.pmTargetCycling=true' + LineEnding +
            'poh.showMythicalCape=true' + LineEnding +
            'itemCharge.showAmuletOfBountyCharges=true' + LineEnding +
            'grounditems.hideUnderValue=0' + LineEnding +
            'implings.showbaby=NONE' + LineEnding +
            'runelite.xptrackerplugin=false' + LineEnding +
            'reportButton.time=LOGIN_TIME' + LineEnding +
            'runelite.cannonplugin=false' + LineEnding +
            'menuentryswapper.swapPick=false' + LineEnding +
            'grandexchange.enableGELimitReset=true' + LineEnding +
            'chatnotification.notifyOnOwnName={"enabled"\:false,"initialized"\:false,"override"\:false,"tray"\:false,"volume"\:0,"timeout"\:0,"gameMessage"\:false,"sendWhenFocused"\:false}' + LineEnding +
            'party.statusOverlayStamina=false' + LineEnding +
            'runelite.npcindicatorsplugin=false' + LineEnding +
            'timers.showDfsSpecial=true' + LineEnding +
            'hiscore.virtualLevels=true' + LineEnding +
            'runecraft.showDeath=true' + LineEnding +
            'xpglobes.showXpLeft=true' + LineEnding +
            'dailytaskindicators.showHerbBoxes=true' + LineEnding +
            'poh.showPools=true' + LineEnding +
            'motherlode.showVeins=true' + LineEnding +
            'runecraft.degradingNotification={"enabled"\:true,"initialized"\:false,"override"\:false,"tray"\:false,"volume"\:0,"timeout"\:0,"gameMessage"\:false,"sendWhenFocused"\:false}' + LineEnding +
            'itemprices.showEA=true' + LineEnding +
            'driftnet.highlightUntaggedFish=true' + LineEnding +
            'timers.showDivine=true' + LineEnding +
            'pyramidplunder.highlightSpeartrapColor=-14336' + LineEnding +
            'grounditems.highValuePrice=1000000' + LineEnding +
            'implings.showninja=NONE' + LineEnding +
            'woodcutting.forestryPheasantControlNotification={"enabled"\:true,"initialized"\:false,"override"\:false,"tray"\:false,"volume"\:0,"timeout"\:0,"gameMessage"\:false,"sendWhenFocused"\:false}' + LineEnding +
            'prayer.prayerIndicatorOverheads=false' + LineEnding +
            'tileindicators.highlightHoveredTile=false' + LineEnding +
            'runelite.gameAlwaysOnTop=false' + LineEnding +
            'fishing.trawlerContribution=true' + LineEnding +
            'textrecolor.opaqueClanMessageHighlight=-16777216' + LineEnding +
            'prayer.prayerFlickAlwaysOn=false' + LineEnding +
            'npcindicators.borderWidth=2.0' + LineEnding +
            'nightmareZone.recurrentdamagenotification={"enabled"\:false,"initialized"\:false,"override"\:false,"tray"\:false,"volume"\:0,"timeout"\:0,"gameMessage"\:false,"sendWhenFocused"\:false}' + LineEnding +
            'slayer.itemoverlay=true' + LineEnding +
            'chatcommands.clue=true' + LineEnding +
            'kingdomofmiscellania.sendNotifications=false' + LineEnding +
            'woodcutting.forestryStrugglingSaplingNotification={"enabled"\:true,"initialized"\:false,"override"\:false,"tray"\:false,"volume"\:0,"timeout"\:0,"gameMessage"\:false,"sendWhenFocused"\:false}' + LineEnding +
            'roofremoval.removeHovered=true' + LineEnding +
            'worldmap.jewelleryIcon=true' + LineEnding +
            'tileindicators.hoveredTileBorderWidth=2.0' + LineEnding +
            'worldmap.questStartTooltips=true' + LineEnding +
            'nightmareZone.overloadearlywarningseconds=10' + LineEnding +
            'dailytaskindicators.showDynamite=false' + LineEnding +
            'screenshot.valuableDropThreshold=0' + LineEnding +
            'itemCharge.dodgyNotification={"enabled"\:true,"initialized"\:false,"override"\:false,"tray"\:false,"volume"\:0,"timeout"\:0,"gameMessage"\:false,"sendWhenFocused"\:false}' + LineEnding +
            'dailytaskindicators.showBonemeal=false' + LineEnding +
            'tithefarmplugin.hexColorGrown=-16721664' + LineEnding +
            'runelite.lockWindowSize=false' + LineEnding +
            'attackIndicator.warnForAttack=false' + LineEnding +
            'boosts.displayNextDebuffChange=NEVER' + LineEnding +
            'mta.alchemy=true' + LineEnding +
            'fairyrings.autoOpen=true' + LineEnding +
            'runelite.wikiplugin=false' + LineEnding +
            'runelite.timersplugin=false' + LineEnding +
            'runelite.notificationVolume=100' + LineEnding +
            'boosts.boostThreshold=0' + LineEnding +
            'barrows.deadBrotherLocColor=-65536' + LineEnding +
            'randomevents.notifyBob={"enabled"\:false,"initialized"\:false,"override"\:false,"tray"\:false,"volume"\:0,"timeout"\:0,"gameMessage"\:false,"sendWhenFocused"\:false}' + LineEnding +
            'runelite.infoplugin=false' + LineEnding +
            'menuentryswapper.shopSell=OFF' + LineEnding +
            'playerindicators.colorPlayerMenu=true' + LineEnding +
            'grandexchange.geSearchMode=DEFAULT' + LineEnding +
            'xpglobes.Progress\ orb\ outline\ color=-16777216' + LineEnding +
            'grounditems.hiddenColor=-8355712' + LineEnding +
            'xpglobes.showActionsLeft=true' + LineEnding +
            'timetracking.defaultTimerMinutes=5' + LineEnding +
            'specialcounter.specDropColor=-1' + LineEnding +
            'interacthighlight.objectInteractHighlightColor=-1862336512' + LineEnding +
            'textrecolor.opaqueGameMessageHighlight=-1109984' + LineEnding +
            'runelite.automaticResizeType=KEEP_GAME_SIZE' + LineEnding +
            'itemprices.hideInventory=true' + LineEnding +
            'agility.lapsToLevel=true' + LineEnding +
            'itemstat.showStatsInBank=true' + LineEnding +
            'itemCharge.showExpeditiousBraceletCharges=true' + LineEnding +
            'logouttimer.idleTimeout=5' + LineEnding +
            'interacthighlight.borderWidth=4' + LineEnding +
            'lowmemory.lowDetail=true' + LineEnding +
            'opponentinfo.hitpointsDisplayStyle=HITPOINTS' + LineEnding +
            'xpdrop.hideSkillIcons=false' + LineEnding +
            'randomevents.removeMenuOptions=true' + LineEnding +
            'hunterplugin.maniacalMonkeyNotify={"enabled"\:false,"initialized"\:false,"override"\:false,"tray"\:false,"volume"\:0,"timeout"\:0,"gameMessage"\:false,"sendWhenFocused"\:false}' + LineEnding +
            'herbiboar.colorTunnel=-16711936' + LineEnding +
            'slayer.highlightOutline=false' + LineEnding +
            'gpu.anisotropicFilteringLevel=1' + LineEnding +
            'cannon.showDoubleHitSpot=false' + LineEnding +
            'runelite.diaryrequirementsplugin=false' + LineEnding +
            'mta.telekinetic=true' + LineEnding +
            'runelite.screenshotplugin=false' + LineEnding +
            'banktags.rememberTab=true' + LineEnding +
            'music.muteOtherAreaNPCSounds=false' + LineEnding +
            'interfaceStyles.condensePlayerOptions=false' + LineEnding +
            'loottracker.priceType=GRAND_EXCHANGE' + LineEnding +
            'itemCharge.showExplorerRingCharges=true' + LineEnding +
            'runelite.sidebarToggleKey=122\:128' + LineEnding +
            'tileindicators.hoveredTileFillColor=838860800' + LineEnding +
            'grounditems.lootbeamStyle=MODERN' + LineEnding +
            'specialcounter.dragonWarhammerThreshold=0' + LineEnding +
            'zoom.rightClickMenuBlocksCamera=true' + LineEnding +
            'itemCharge.ringOfForgingNotification={"enabled"\:true,"initialized"\:false,"override"\:false,"tray"\:false,"volume"\:0,"timeout"\:0,"gameMessage"\:false,"sendWhenFocused"\:false}' + LineEnding +
            'runelite.tooltipFontType=SMALL' + LineEnding +
            'xpTracker.onScreenDisplayModeBottom=XP_HOUR' + LineEnding +
            'npcindicators.ignoreDeadNpcs=true' + LineEnding +
            'cannon.showInfobox=false' + LineEnding +
            'chatfilter.filterFriends=false' + LineEnding +
            'gpu.colorBlindMode=NONE' + LineEnding +
            'specialcounter.specDropMisses=false' + LineEnding +
            'poh.showGlory=true' + LineEnding +
            'motherlode.showRocks=true' + LineEnding +
            'runelite.tithefarmplugin=false' + LineEnding +
            'worldhopper.showMessage=true' + LineEnding +
            'textrecolor.opaqueClanInfoHighlight=-65536' + LineEnding +
            'itemstat.showWeight=true' + LineEnding +
            'implings.natureColor=-10712481' + LineEnding +
            'playerindicators.drawMinimapNames=false' + LineEnding +
            'textrecolor.transparentGameMessageHighlight=-1109984' + LineEnding +
            'grounditems.groundItemTimers=OFF' + LineEnding +
            'interfaceStyles.gameframe=AROUND_2010' + LineEnding +
            'mta.graveyard=true' + LineEnding +
            'randomevents.notifyForester={"enabled"\:false,"initialized"\:false,"override"\:false,"tray"\:false,"volume"\:0,"timeout"\:0,"gameMessage"\:false,"sendWhenFocused"\:false}' + LineEnding +
            'gpu.removeVertexSnapping=true' + LineEnding +
            'runelite.pestcontrolplugin=false' + LineEnding +
            'bank.rightClickBankLoot=false' + LineEnding +
            'runelite.attackstylesplugin=false' + LineEnding +
            'npcindicators.highlightHull=true' + LineEnding +
            'implings.babyColor=-5140557' + LineEnding +
            'runelite.hunterplugin=false' + LineEnding +
            'chatcommands.killcount=true' + LineEnding +
            'implings.showyoung=NONE' + LineEnding +
            'raids.scoutOverlayAtBank=true' + LineEnding +
            'runelite.overlayBackgroundColor=-1673118414' + LineEnding +
            'itemidentification.showHerbSeeds=true' + LineEnding +
            'specialcounter.darklightThreshold=0' + LineEnding +
            'fpscontrol.maxFps=50' + LineEnding +
            'poison.changeHealthIcon=true' + LineEnding +
            'runelite.tooltipPosition=UNDER_CURSOR' + LineEnding +
            'inventoryViewer.hiddenDefault=false' + LineEnding +
            'runelite.herbiboarplugin=false' + LineEnding +
            'itemstat.alwaysShowBaseStats=false' + LineEnding +
            'xpTracker.xpPanelLabel2=XP_LEFT' + LineEnding +
            'xpTracker.xpPanelLabel3=XP_HOUR' + LineEnding +
            'xpTracker.xpPanelLabel4=ACTIONS_LEFT' + LineEnding +
            'zoom.rightClickObjects=true' + LineEnding +
            'menuentryswapper.swapHelp=true' + LineEnding +
            'poison.showInfoboxes=false' + LineEnding +
            'npcindicators.highlightMenuNames=false' + LineEnding +
            'runelite.infoBoxVertical=false' + LineEnding +
            'grounditems.hiddenItems=Vial, Ashes, Coins, Bones, Bucket, Jug, Seaweed' + LineEnding +
            'xpTracker.xpPanelLabel1=XP_GAINED' + LineEnding +
            'loottracker.showPriceType=false' + LineEnding +
            'clanchat.publicChatIcons=false' + LineEnding +
            'fishing.onlyCurrent=false' + LineEnding +
            'gpu.vsyncMode=OFF' + LineEnding +
            'runelite.loottrackerplugin=false' + LineEnding +
            'hiscore.autocomplete=true' + LineEnding +
            'itemidentification.showHerbs=false' + LineEnding +
            'timers.showOverload=true' + LineEnding +
            'screenshot.untradeableDrop=false' + LineEnding +
            'kourendLibrary.hideButton=true' + LineEnding +
            'randomevents.notifyPillory={"enabled"\:false,"initialized"\:false,"override"\:false,"tray"\:false,"volume"\:0,"timeout"\:0,"gameMessage"\:false,"sendWhenFocused"\:false}' + LineEnding +
            'fishing.showIcons=true' + LineEnding +
            'objectindicators.borderWidth=2.0' + LineEnding +
            'agility.overlayColor=-16711936' + LineEnding +
            'randomevents.notifyFrog={"enabled"\:false,"initialized"\:false,"override"\:false,"tray"\:false,"volume"\:0,"timeout"\:0,"gameMessage"\:false,"sendWhenFocused"\:false}' + LineEnding +
            'menuentryswapper.swapAbyssTeleport=true' + LineEnding +
            'inventorygrid.highlightColor=755040000' + LineEnding +
            'chathistory.retainChatHistory=true' + LineEnding +
            'textrecolor.transparentExamineHighlight=-16711936' + LineEnding +
            'timetracking.timerWarningThreshold=10' + LineEnding +
            'cooking.statTimeout=5' + LineEnding +
            'tileindicators.highlightCurrentTile=false' + LineEnding +
            'corp.markDarkCore=true' + LineEnding +
            'menuentryswapper.swapAdmire=true' + LineEnding +
            'opponentinfo.showOpponentHealthOverlay=true' + LineEnding +
            'runelite.kourendlibraryplugin=false' + LineEnding +
            'woodcutting.highlightPheasantNest=true' + LineEnding +
            'menuentryswapper.swapHomePortal=HOME' + LineEnding +
            'cannon.showCannonSpots=true' + LineEnding +
            'runelite.discordplugin=false' + LineEnding +
            'friendNotes.showIcons=true' + LineEnding +
            'entityhider.hideClanChatMembers=false' + LineEnding +
            'agility.agilityArenaTimer=true' + LineEnding +
            'randomevents.notifyMaze={"enabled"\:false,"initialized"\:false,"override"\:false,"tray"\:false,"volume"\:0,"timeout"\:0,"gameMessage"\:false,"sendWhenFocused"\:false}' + LineEnding +
            'barrows.brotherLocColor=-16711681' + LineEnding +
            'playerindicators.teamMemberColor=-15503625' + LineEnding +
            'agility.highlightSepulchreSkilling=true' + LineEnding +
            'regenmeter.showWhenNoChange=false' + LineEnding +
            'music.mutePrayerSounds=false' + LineEnding +
            'party.statusOverlaySpec=false' + LineEnding +
            'playerindicators.clanMemberColor=-5635841' + LineEnding +
            'textrecolor.opaqueClanChatGuestMessageHighlight=-16777216' + LineEnding +
            'npcindicators.highlightTile=false' + LineEnding +
            'keyremapping.f1=49\:0' + LineEnding +
            'entityhider.hidePets=false' + LineEnding +
            'keyremapping.f3=51\:0' + LineEnding +
            'keyremapping.f2=50\:0' + LineEnding +
            'woodcutting.highlightMulch=true' + LineEnding +
            'itemidentification.showComposts=false' + LineEnding +
            'agility.sepulchreHighlightColor=-16711936' + LineEnding +
            'smelting.statTimeout=5' + LineEnding +
            'chathistory.copyToClipboard=true' + LineEnding +
            'statusbars.enableCounter=false' + LineEnding +
            'itemCharge.showInfoboxes=false' + LineEnding +
            'woodcutting.showWoodcuttingStats=true' + LineEnding +
            'runelite.blastmineplugin=false' + LineEnding +
            'playerindicators.highlightOthers=DISABLED' + LineEnding +
            'prayer.showPrayerBar=false' + LineEnding +
            'chatcommands.bhRogue=true' + LineEnding +
            'itemstat.colorBetterCapped=-1118669' + LineEnding +
            'nightmareZone.absorptionthreshold=50' + LineEnding +
            'itemstat.relative=true' + LineEnding +
            'keyremapping.control=0\:128' + LineEnding +
            'playerindicators.ownNameColor=-16729900' + LineEnding +
            'specialcounter.defenceDrainInfobox=true' + LineEnding +
            'timers.showVengeanceActive=true' + LineEnding +
            'worldhopper.regionFilter=[]' + LineEnding +
            'runelite.infoBoxSize=35' + LineEnding +
            'runelite.worldhopperplugin=false' + LineEnding +
            'worldmap.fishingSpotTooltips=true' + LineEnding +
            'zoom.outerLimit=0' + LineEnding +
            'itemCharge.showGuthixRestDoses=true' + LineEnding +
            'bank.bankPinKeyboard=false' + LineEnding +
            'interacthighlight.npcAttackHighlightColor=-1862336512' + LineEnding +
            'inventorygrid.showHighlight=true' + LineEnding +
            'itemCharge.showBloodEssenceCharges=true' + LineEnding +
            'idlenotifier.animationidle={"enabled"\:true,"initialized"\:false,"override"\:false,"tray"\:false,"volume"\:0,"timeout"\:0,"gameMessage"\:false,"sendWhenFocused"\:false}' + LineEnding +
            'timetracking.timerNotification={"enabled"\:false,"initialized"\:false,"override"\:false,"tray"\:false,"volume"\:0,"timeout"\:0,"gameMessage"\:false,"sendWhenFocused"\:false}' + LineEnding +
            'herbiboar.showStart=true' + LineEnding +
            'runelite.playerindicatorsplugin=false' + LineEnding +
            'timers.showTeleblock=true' + LineEnding +
            'randomevents.notifyCerters={"enabled"\:false,"initialized"\:false,"override"\:false,"tray"\:false,"volume"\:0,"timeout"\:0,"gameMessage"\:false,"sendWhenFocused"\:false}' + LineEnding +
            'itemCharge.lowWarningColor=-256' + LineEnding +
            'raids.copyToClipboard=true' + LineEnding +
            'interacthighlight.npcShowHover=true' + LineEnding +
            'barrows.showBrotherLoc=true' + LineEnding +
            'runelite.flashNotification=DISABLED' + LineEnding +
            'agility.trapOverlay=true' + LineEnding +
            'runelite.cookingplugin=false' + LineEnding +
            'boosts.displayIndicators=true' + LineEnding +
            'nightmareZone.absorptioncolorbelowthreshold=-65536' + LineEnding +
            'timers.showLiquidAdrenaline=true' + LineEnding +
            'chatcommands.pets=true' + LineEnding +
            'npcUnaggroArea.notifyExpire={"enabled"\:false,"initialized"\:false,"override"\:false,"tray"\:false,"volume"\:0,"timeout"\:0,"gameMessage"\:false,"sendWhenFocused"\:false}' + LineEnding +
            'timestamp.format=[HH\:mm]' + LineEnding +
            'objectindicators.highlightOutline=false' + LineEnding +
            'menuentryswapper.swapAssignment=true' + LineEnding +
            'menuentryswapper.shopBuy=OFF' + LineEnding +
            'menuentryswapper.swapDepositItems=false' + LineEnding +
            'implings.dragonColor=-2992821' + LineEnding +
            'menuentryswapper.objectShiftClickWalkHere=false' + LineEnding +
            'bank.rightClickPlaceholders=false' + LineEnding +
            'runelite.dailytasksplugin=false' + LineEnding +
            'gpu.unlockFps=true' + LineEnding +
            'zoom.cameraSpeed=1.0' + LineEnding +
            'npcUnaggroArea.hideIfOutOfCombat=false' + LineEnding +
            'discord.showDungeonActivity=true' + LineEnding +
            'driftnet.tagAnnette=true' + LineEnding +
            'playerindicators.playerNamePosition=ABOVE_HEAD' + LineEnding +
            'itemCharge.showWateringCanCharges=true' + LineEnding +
            'entityhider.hideNPCs=false' + LineEnding +
            'itemCharge.expeditiousNotification={"enabled"\:true,"initialized"\:false,"override"\:false,"tray"\:false,"volume"\:0,"timeout"\:0,"gameMessage"\:false,"sendWhenFocused"\:false}' + LineEnding +
            'music.muteAmbientSounds=false' + LineEnding +
            'loottracker.showRaidsLootValue=true' + LineEnding +
            'itemCharge.amuletOfChemistryNotification={"enabled"\:true,"initialized"\:false,"override"\:false,"tray"\:false,"volume"\:0,"timeout"\:0,"gameMessage"\:false,"sendWhenFocused"\:false}' + LineEnding +
            'agility.lapTimeout=5' + LineEnding +
            'grounditems.highlightTiles=false' + LineEnding +
            'grounditems.insaneValuePrice=10000000' + LineEnding +
            'worldmap.dungeonTooltips=true' + LineEnding +
            'runelite.screenmarkerplugin=false' + LineEnding +
            'grandexchange.showTotal=true' + LineEnding +
            'runelite.blastfurnaceplugin=false' + LineEnding +
            'runelite.pohplugin=false' + LineEnding +
            'inventorygrid.showItem=true' + LineEnding +
            'regenmeter.notifyBeforeHpRegenDuration=0' + LineEnding +
            'timers.showHomeMinigameTeleports=true' + LineEnding +
            'keyremapping.f9=57\:0' + LineEnding +
            'runelite.slayerplugin=false' + LineEnding +
            'bank.rightClickBankEquip=false' + LineEnding +
            'keyremapping.f8=56\:0' + LineEnding +
            'menuentryswapper.swapArdougneCloak=WEAR' + LineEnding +
            'reportButton.switchTimeFormat=TIME_12H' + LineEnding +
            'slayer.superiornotification={"enabled"\:true,"initialized"\:false,"override"\:false,"tray"\:false,"volume"\:0,"timeout"\:0,"gameMessage"\:false,"sendWhenFocused"\:false}' + LineEnding +
            'menuentryswapper.swapFairyRing=LAST_DESTINATION' + LineEnding +
            'keyremapping.f5=53\:0' + LineEnding +
            'keyremapping.f4=52\:0' + LineEnding +
            'keyremapping.f7=55\:0' + LineEnding +
            'runelite.chathistoryplugin=false' + LineEnding +
            'motherlode.statTimeout=5' + LineEnding +
            'keyremapping.f6=54\:0' + LineEnding +
            'runepouch.fontcolor=-256' + LineEnding +
            'runenergy.replaceOrbText=false' + LineEnding +
            'stretchedmode.keepAspectRatio=false' + LineEnding +
            'loottracker.pvpKillChatMessage=false' + LineEnding +
            'itemCharge.showBasketCharges=true' + LineEnding +
            'mousehighlight.disableSpellbooktooltip=false' + LineEnding +
            'dpscounter.autoreset=false' + LineEnding +
            'chatfilter.maxRepeatedPublicChats=0' + LineEnding +
            'wintertodt.notifyFullInv=true' + LineEnding +
            'implings.spawnColor=-1' + LineEnding +
            'entityhider.hideLocalPlayer2D=false' + LineEnding +
            'zoom.controlFunction=NONE' + LineEnding +
            'xpdrop.magePrayerColor=-15368019' + LineEnding +
            'npcUnaggroArea.npcUnaggroAlwaysActive=false' + LineEnding +
            'blastmine.showWarningOverlay=true' + LineEnding +
            'tileindicators.currentTileFillColor=838860800' + LineEnding +
            'wiki.showWikiMinimapButton=true' + LineEnding +
            'driftnet.annetteTagColor=-65536' + LineEnding +
            'implings.shownature=NONE' + LineEnding +
            'interacthighlight.npcInteractHighlightColor=-1862336512' + LineEnding +
            'idlenotifier.prayerNotification={"enabled"\:false,"initialized"\:false,"override"\:false,"tray"\:false,"volume"\:0,"timeout"\:0,"gameMessage"\:false,"sendWhenFocused"\:false}' + LineEnding +
            'idlenotifier.logoutidle={"enabled"\:true,"initialized"\:false,"override"\:false,"tray"\:false,"volume"\:0,"timeout"\:0,"gameMessage"\:false,"sendWhenFocused"\:false}' + LineEnding +
            'runelite.runepouchplugin=false' + LineEnding +
            'runelite.clientBounds=562\:276\:765\:503\:g' + LineEnding +
            'screenshot.friendDeath=false' + LineEnding +
            'npcindicators.showRespawnTimer=false' + LineEnding +
            'xpglobes.showTimeTilGoal=true' + LineEnding +
            'itemCharge.veryLowWarning=1' + LineEnding +
            'runelite.notificationTray=true' + LineEnding +
            'entityhider.hideThralls=false' + LineEnding +
            'loginscreen.pasteenabled=false' + LineEnding +
            'dpscounter.autopause=false' + LineEnding +
            'hiscore.playerOption=true' + LineEnding +
            'discord.showRegionsActivity=true' + LineEnding +
            'menuentryswapper.swapTan=false' + LineEnding +
            'specialcounter.specDrops=true' + LineEnding +
            'inventorygrid.showGrid=true' + LineEnding +
            'boosts.displayBoosts=COMBAT' + LineEnding +
            'npcindicators.npcColor=-16711681' + LineEnding +
            'nightmareZone.zappernotification={"enabled"\:false,"initialized"\:false,"override"\:false,"tray"\:false,"volume"\:0,"timeout"\:0,"gameMessage"\:false,"sendWhenFocused"\:false}' + LineEnding +
            'timers.showStamina=true' + LineEnding +
            'itemidentification.showTablets=false' + LineEnding +
            'clanchat.clanChatShowOnlineMemberCount=false' + LineEnding +
            'grounditems.highValueColor=-27136' + LineEnding +
            'itemidentification.showSpecialSeeds=false' + LineEnding +
            'driftnet.timeoutDelay=60' + LineEnding +
            'implings.showearth=NONE' + LineEnding +
            'runelite.regenmeterplugin=false' + LineEnding +
            'worldmap.ancientSpellbookIcon=true' + LineEnding +
            'discord.actionTimeout=5' + LineEnding +
            'itemCharge.showRingOfForgingCount=true' + LineEnding +
            'woodcutting.forestryPoachersNotification={"enabled"\:true,"initialized"\:false,"override"\:false,"tray"\:false,"volume"\:0,"timeout"\:0,"gameMessage"\:false,"sendWhenFocused"\:false}' + LineEnding +
            'barbarianAssault.showTimer=true' + LineEnding +
            'specialcounter.bandosGodswordThreshold=0' + LineEnding +
            'xpdrop.rangePrayerColor=-15368019' + LineEnding +
            'grounditems.lowValueColor=-10046721' + LineEnding +
            'worldmap.transportationTooltips=true' + LineEnding +
            'worldmap.agilityShortcutTooltips=true' + LineEnding +
            'screenshot.boss=false' + LineEnding +
            'runecraft.showBody=true' + LineEnding +
            'clanchat.joinLeaveTimeout=20' + LineEnding +
            'specialcounter.thresholdNotification={"enabled"\:false,"initialized"\:false,"override"\:false,"tray"\:false,"volume"\:0,"timeout"\:0,"gameMessage"\:false,"sendWhenFocused"\:false}' + LineEnding +
            'gpu.antiAliasingMode=MSAA_2' + LineEnding +
            'dailytaskindicators.showSand=false' + LineEnding +
            'antiDrag.disableOnCtrl=false' + LineEnding +
            'implings.showessence=NONE' + LineEnding +
            'menuentryswapper.swapStairsShiftClick=CLIMB' + LineEnding +
            'randomevents.notifyTwin={"enabled"\:false,"initialized"\:false,"override"\:false,"tray"\:false,"volume"\:0,"timeout"\:0,"gameMessage"\:false,"sendWhenFocused"\:false}' + LineEnding +
            'agility.lapsPerHour=true' + LineEnding +
            'itemstat.theoretical=false' + LineEnding +
            'agility.highlightStick=true' + LineEnding +
            'idlenotifier.lowEnergy=0' + LineEnding +
            'woodcutting.highlightBeeHive=true' + LineEnding +
            'kourendLibrary.hideDuplicateBook=true' + LineEnding +
            'playerindicators.clanchatMenuIcons=true' + LineEnding +
            'prayer.prayerIndicator=false' + LineEnding +
            'implings.eclecticColor=-7234747' + LineEnding +
            'woodcutting.forestryRisingRootsNotification={"enabled"\:true,"initialized"\:false,"override"\:false,"tray"\:false,"volume"\:0,"timeout"\:0,"gameMessage"\:false,"sendWhenFocused"\:false}' + LineEnding +
            'gpu.drawDistance=50' + LineEnding +
            'blastfurnace.showBarDispenser=false' + LineEnding +
            'combatlevel.showPreciseCombatLevel=true' + LineEnding +
            'fishing.aerialOverlayColor=-16711936' + LineEnding +
            'menuentryswapper.swapTrade=true' + LineEnding +
            'teamCapes.clanChatMemberCounter=false' + LineEnding +
            'itemidentification.textColor=-1' + LineEnding +
            'idlenotifier.prayer=1' + LineEnding +
            'woodcutting.statTimeout=5' + LineEnding +
            'grounditems.highlightedColor=-5635841' + LineEnding +
            'runelite.usernameInTitle=false' + LineEnding +
            'clanchat.clanChatShowJoinLeave=false' + LineEnding +
            'chatnotification.notifyOnTrade={"enabled"\:false,"initialized"\:false,"override"\:false,"tray"\:false,"volume"\:0,"timeout"\:0,"gameMessage"\:false,"sendWhenFocused"\:false}' + LineEnding +
            'xpTracker.pauseSkillAfter=0' + LineEnding +
            'timetracking.farmingContractInfoBox=true' + LineEnding +
            'grounditems.mediumValuePrice=100000' + LineEnding +
            'prayer.replaceOrbText=false' + LineEnding +
            'slayer.statTimeout=5' + LineEnding +
            'woodcutting.forestryLeprechaunNotification=true' + LineEnding +
            'poh.showExitPortal=true' + LineEnding +
            'itemCharge.bindingNotification={"enabled"\:true,"initialized"\:false,"override"\:false,"tray"\:false,"volume"\:0,"timeout"\:0,"gameMessage"\:false,"sendWhenFocused"\:false}' + LineEnding +
            'implings.showeclectic=NONE' + LineEnding +
            'screenshot.pets=true' + LineEnding +
            'slayer.taskCommand=true' + LineEnding +
            'interfaceStyles.menuAlpha=255' + LineEnding +
            'itemidentification.showSacks=false' + LineEnding +
            'fishing.showMinnowOverlay=true' + LineEnding +
            'menuentryswapper.leftClickCustomization=true' + LineEnding +
            'menuentryswapper.swapTravel=true' + LineEnding +
            'inventorygrid.gridColor=771751935' + LineEnding +
            'clanchat.clanChatIcons=true' + LineEnding +
            'pyramidplunder.highlightSpeartraps=true' + LineEnding +
            'worldmap.lunarSpellbookIcon=true' + LineEnding +
            'prayer.prayerDoseOrbStartColor=-16711681' + LineEnding +
            'hunterplugin.hexColorFullTrap=-16711936' + LineEnding +
            'npcUnaggroArea.npcUnaggroShowTimer=true' + LineEnding +
            'worldmap.agilityCourseRooftopIcon=true' + LineEnding +
            'inventorytags.tagFill=false' + LineEnding +
            'itemidentification.showTreeSeeds=false' + LineEnding +
            'textrecolor.opaquePrivateMessageSentHighlight=-16767101' + LineEnding +
            'barrows.showChestValue=true' + LineEnding +
            'minimap.hideMinimap=false' + LineEnding +
            'xpupdater.wiseoldman=false' + LineEnding +
            'worldmap.rareTreeTooltips=true' + LineEnding +
            'itemidentification.showHopSeeds=false' + LineEnding +
            'itemCharge.showFungicideCharges=true' + LineEnding +
            'xpglobes.Progress\ arc\ color=-14336' + LineEnding +
            'interfaceStyles.alwaysStack=false' + LineEnding +
            'woodcutting.showRespawnTimers=true' + LineEnding +
            'poh.showMagicTravel=true' + LineEnding +
            'loginscreen.loginScreen=OFF' + LineEnding +
            'discord.showCityActivity=true' + LineEnding +
            'implings.essenceColor=-14657190' + LineEnding +
            'timers.showArceuusCooldown=false' + LineEnding +
            'pyramidplunder.highlightDoorsColor=-16711936' + LineEnding +
            'itemidentification.showBars=false' + LineEnding +
            'idlenotifier.highEnergy=100' + LineEnding +
            'xpglobes.hideMaxed=false' + LineEnding +
            'zoom.invertPitch=false' + LineEnding +
            'opponentinfo.showOpponentsInMenu=false' + LineEnding +
            'timers.showStaffOfTheDead=true' + LineEnding +
            'runelite.blockExtraMouseButtons=true' + LineEnding +
            'timers.showAbyssalSireStun=true' + LineEnding +
            'playerindicators.highlightPartyMembers=ENABLED' + LineEnding +
            'slayer.highlightTile=false' + LineEnding +
            'attackIndicator.removeWarnedStyles=false' + LineEnding +
            'xpupdater.cml=false' + LineEnding +
            'tileindicators.highlightDestinationTile=true' + LineEnding +
            'fishing.showTiles=true' + LineEnding +
            'zoom.ctrlZoomValue=512' + LineEnding +
            'runecraft.showClickBox=true' + LineEnding +
            'inventoryViewer.hideIfInventoryActive=false' + LineEnding +
            'timers.showSilkDressing=true' + LineEnding +
            'itemstat.geStats=true' + LineEnding +
            'chatcommands.clearSingleWord=8\:128' + LineEnding +
            'clanchat.showIgnoresColor=-65536' + LineEnding +
            'idlenotifier.timeout=5000' + LineEnding +
            'itemstat.equipmentStats=true' + LineEnding +
            'runelite.runecraftplugin=false' + LineEnding +
            'menuentryswapper.swapBoxTrap=true' + LineEnding +
            'itemstat.consumableStats=true' + LineEnding +
            'screenshot.levels=true' + LineEnding +
            'mta.enchantment=true' + LineEnding +
            'itemCharge.recoilNotification={"enabled"\:false,"initialized"\:false,"override"\:false,"tray"\:false,"volume"\:0,"timeout"\:0,"gameMessage"\:false,"sendWhenFocused"\:false}' + LineEnding +
            'nightmareZone.overloadnotification={"enabled"\:true,"initialized"\:false,"override"\:false,"tray"\:false,"volume"\:0,"timeout"\:0,"gameMessage"\:false,"sendWhenFocused"\:false}' + LineEnding +
            'runelite.nightmarezoneplugin=false' + LineEnding +
            'runelite.notificationFlashColor=1191116800' + LineEnding +
            'itemprices.showHAValue=true' + LineEnding +
            'virtuallevels.virtualTotalLevel=true' + LineEnding +
            'herbiboar.colorTrail=-1' + LineEnding +
            'screenshot.wildernessLootChest=true' + LineEnding +
            'bank.seedVaultValue=true' + LineEnding +
            'raids.ccDisplay=false' + LineEnding +
            'tearsofguthix.showGreenTearsTimer=true' + LineEnding +
            'motherlode.showGemsFound=true' + LineEnding +
            'party.statusOverlayRenderSelf=true' + LineEnding +
            'runelite.uiWindowOpacity=100' + LineEnding +
            'raids.scoutOverlay=true' + LineEnding +
            'runecraft.showEarth=true' + LineEnding +
            'hunterplugin.hexColorTransTrap=-14336' + LineEnding +
            'discord.elapsedTime=TOTAL' + LineEnding +
            'attackIndicator.hideAutoRetaliate=false' + LineEnding +
            'entityhider.hideAttackers=false' + LineEnding +
            'statusbars.enableSkillIcon=true' + LineEnding +
            'woodcutting.highlightRitualCircle=true' + LineEnding +
            'menuentryswapper.swapPay=true' + LineEnding +
            'roofremoval.removeDestination=true' + LineEnding +
            'runelite.notificationTimeout=10000' + LineEnding +
            'textrecolor.opaqueClanChatMessageHighlight=-16777216' + LineEnding +
            'infoboxoverlay.orient_InfoBoxOverlay=HORIZONTAL' + LineEnding +
            'opponentinfo.lookupOnInteraction=false' + LineEnding +
            'pyramidplunder.hideTimer=true' + LineEnding +
            'grounditems.mediumValueColor=-6684775' + LineEnding +
            'barbarianAssault.waveTimes=true' + LineEnding +
            'woodcutting.highlightFoxTrap=true' + LineEnding +
            'grounditems.onlyShowLoot=false' + LineEnding +
            'loginscreen.showLoginFire=true' + LineEnding +
            'zoom.inner=false' + LineEnding +
            'prayer.showPrayerTooltip=true' + LineEnding +
            'dailytaskindicators.showFlax=false' + LineEnding +
            'chatnotification.notifyOnBroadcast={"enabled"\:false,"initialized"\:false,"override"\:false,"tray"\:false,"volume"\:0,"timeout"\:0,"gameMessage"\:false,"sendWhenFocused"\:false}' + LineEnding +
            'menuentryswapper.swapExchange=true' + LineEnding +
            'screenshot.copyToClipboard=false' + LineEnding +
            'screenshot.baHighGamble=false' + LineEnding +
            'grounditems.showMenuItemQuantities=true' + LineEnding +
            'specialcounter.elderMaulThreshold=0' + LineEnding +
            'worldhopper.previousKey=37\:192' + LineEnding +
            'menuentryswapper.swapKaramjaGloves=WEAR' + LineEnding +
            'runecraft.showRifts=true' + LineEnding +
            'worldhopper.nextKey=39\:192' + LineEnding +
            'chatcommands.clearEntireChatBox=0\:0' + LineEnding +
            'playerindicators.drawPlayerTiles=false' + LineEnding +
            'grounditems.priceDisplayMode=BOTH' + LineEnding +
            'runelite.friendnotesplugin=false' + LineEnding +
            'inventorytags.showTagOutline=true' + LineEnding +
            'clanchat.showIgnores=true' + LineEnding +
            'menuentryswapper.swapRadasBlessing=EQUIP' + LineEnding +
            'zoom.rightClickExamine=false' + LineEnding +
            'screenshot.duels=false' + LineEnding +
            'discord.showMinigameActivity=true' + LineEnding +
            'itemstat.colorBetterSomecapped=-6492621' + LineEnding +
            'gpu.hideUnrelatedMaps=true' + LineEnding +
            'menuentryswapper.swapGEAbort=false' + LineEnding +
            'npcindicators.outlineFeather=0' + LineEnding +
            'runelite.banktagsplugin=false' + LineEnding +
            'idlenotifier.movementidle={"enabled"\:false,"initialized"\:false,"override"\:false,"tray"\:false,"volume"\:0,"timeout"\:0,"gameMessage"\:false,"sendWhenFocused"\:false}' + LineEnding +
            'runelite.minimapplugin=false' + LineEnding +
            'implings.showCrystal=NONE' + LineEnding +
            'woodcutting.forestryFloweringTreeNotification={"enabled"\:true,"initialized"\:false,"override"\:false,"tray"\:false,"volume"\:0,"timeout"\:0,"gameMessage"\:false,"sendWhenFocused"\:false}' + LineEnding +
            'wintertodt.notifyBrazierDamage=INTERRUPT' + LineEnding +
            'chatfilter.stripAccents=false' + LineEnding +
            'tithefarmplugin.hexColorUnwatered=-17664' + LineEnding +
            'banktags.removeTabSeparators=false' + LineEnding +
            'defaultworld.defaultWorld=0' + LineEnding +
            'randomevents.notifyArnav={"enabled"\:false,"initialized"\:false,"override"\:false,"tray"\:false,"volume"\:0,"timeout"\:0,"gameMessage"\:false,"sendWhenFocused"\:false}' + LineEnding +
            'teamCapes.friendsChatMemberCounter=false' + LineEnding +
            'textrecolor.transparentClanChatInfoHighlight=-65536' + LineEnding +
            'runelite.gameSize=765x503' + LineEnding +
            'discord.showBossActivity=true' + LineEnding +
            'friendlist.showWorldOnLogin=false' + LineEnding +
            'raids.scoutOverlayInRaid=true' + LineEnding +
            'hiscore.bountylookup=false' + LineEnding +
            'slayer.highlightHull=false' + LineEnding +
            'worldmap.farmingpatchTooltips=true' + LineEnding +
            'kourendLibrary.alwaysShowVarlamoreEnvoy=false' + LineEnding +
            'fishing.showFishingStats=true' + LineEnding +
            'randomevents.notifyDunce={"enabled"\:false,"initialized"\:false,"override"\:false,"tray"\:false,"volume"\:0,"timeout"\:0,"gameMessage"\:false,"sendWhenFocused"\:false}' + LineEnding +
            'blastmine.showOreOverlay=true' + LineEnding +
            'worldhopper.displayPing=false' + LineEnding +
            'poh.showBurner=true' + LineEnding +
            'agility.highlightShortcuts=true' + LineEnding +
            'runelite.prayerplugin=false' + LineEnding +
            'bank.showExact=false' + LineEnding +
            'idlenotifier.oxygenNotification={"enabled"\:false,"initialized"\:false,"override"\:false,"tray"\:false,"volume"\:0,"timeout"\:0,"gameMessage"\:false,"sendWhenFocused"\:false}' + LineEnding +
            'itemidentification.showOres=false' + LineEnding +
            'woodcutting.highlightFlowers=true' + LineEnding +
            'playerindicators.friendNameColor=-16725933' + LineEnding +
            'npcindicators.highlightSouthWestTile=false' + LineEnding +
            'interacthighlight.objectShowInteract=true' + LineEnding +
            'dailytaskindicators.showArrows=false' + LineEnding +
            'timetracking.preferSoonest=false' + LineEnding +
            'runelite.accountplugin=false' + LineEnding +
            'agility.showLapCount=true' + LineEnding +
            'zoom.zoomIncrement=25' + LineEnding +
            'runelite.spellbookplugin=false' + LineEnding +
            'itemCharge.lowWarning=2' + LineEnding +
            'xpTracker.onScreenDisplayMode=XP_GAINED' + LineEnding +
            'pyramidplunder.highlightedChestFloor=9' + LineEnding +
            'implings.showgourmet=NONE' + LineEnding +
            'itemidentification.showLogs=false' + LineEnding +
            'runelite.agilityplugin=false' + LineEnding +
            'itemCharge.showBraceletOfClayCharges=true' + LineEnding +
            'chatcommands.sw=true' + LineEnding +
            'fishing.minnowsOverlayColor=-65536' + LineEnding +
            'defaultworld.lastWorld=0' + LineEnding +
            'runelite.grandexchangeplugin=false' + LineEnding +
            'xpTracker.logoutPausing=true' + LineEnding +
            'timers.showArceuus=true' + LineEnding +
            'runelite.puzzlesolverplugin=false' + LineEnding +
            'loottracker.syncPanel=true' + LineEnding +
            'raids.enableLayoutWhitelist=false' + LineEnding +
            'zoom.middleClickMenu=false' + LineEnding +
            'agility.showClickboxes=true' + LineEnding +
            'runelite.chatchannelplugin=false' + LineEnding +
            'worldmap.agilityCourseTooltips=true' + LineEnding +
            'raids.enableRotationWhitelist=false' + LineEnding +
            'keyremapping.up=87\:0' + LineEnding +
            'worldhopper.menuOption=true' + LineEnding +
            'chatnotification.notifyOnHighlight={"enabled"\:false,"initialized"\:false,"override"\:false,"tray"\:false,"volume"\:0,"timeout"\:0,"gameMessage"\:false,"sendWhenFocused"\:false}' + LineEnding +
            'gpu.useComputeShaders=true' + LineEnding +
            'attackIndicator.showChatWarnings=true' + LineEnding +
            'timers.showAntipoison=true' + LineEnding +
            'specialcounter.arclightThreshold=0' + LineEnding +
            'runelite.uiEnableCustomChrome=false' + LineEnding +
            'antiDrag.dragDelay=30' + LineEnding +
            'regenmeter.showHitpoints=true' + LineEnding +
            'wintertodt.roundNotification=5' + LineEnding +
            'itemprices.showWhileAlching=true' + LineEnding +
            'menuentryswapper.swapPortalNexus=false' + LineEnding +
            'menuentryswapper.swapPrivate=false' + LineEnding +
            'minimap.zoom=true' + LineEnding +
            'textrecolor.transparentPrivateMessageSentHighlight=-1' + LineEnding +
            'runecraft.showMind=true' + LineEnding +
            'grounditems.showLootbeamTier=HIGH' + LineEnding +
            'banktags.position=0' + LineEnding +
            'nightmareZone.ultimateforcenotification={"enabled"\:false,"initialized"\:false,"override"\:false,"tray"\:false,"volume"\:0,"timeout"\:0,"gameMessage"\:false,"sendWhenFocused"\:false}' + LineEnding +
            'itemidentification.showFlowerSeeds=false' + LineEnding +
            'clanchat.guestClanChatShowJoinLeave=false' + LineEnding +
            'textrecolor.transparentClanInfoHighlight=-65536' + LineEnding +
            'xpTracker.intermediateLevelMarkers=false' + LineEnding +
            'driftnet.countColor=-1' + LineEnding +
            'npcindicators.drawNames=false' + LineEnding +
            'randomevents.notifySandwich={"enabled"\:false,"initialized"\:false,"override"\:false,"tray"\:false,"volume"\:0,"timeout"\:0,"gameMessage"\:false,"sendWhenFocused"\:false}' + LineEnding +
            'randomevents.notifyCountCheck={"enabled"\:false,"initialized"\:false,"override"\:false,"tray"\:false,"volume"\:0,"timeout"\:0,"gameMessage"\:false,"sendWhenFocused"\:false}' + LineEnding +
            'playerindicators.partyMemberNameColor=-1410213' + LineEnding +
            'interacthighlight.npcHoverHighlightColor=-1862271232' + LineEnding +
            'stretchedmode.scalingFactor=50' + LineEnding +
            'statusbars.enableRestorationBars=true' + LineEnding +
            'runelite.infoBoxTextOutline=false' + LineEnding +
            'runelite.rememberScreenBounds=false' + LineEnding +
            'implings.gourmetColor=-5667998' + LineEnding +
            'chatnotification.notifyOnDuel={"enabled"\:false,"initialized"\:false,"override"\:false,"tray"\:false,"volume"\:0,"timeout"\:0,"gameMessage"\:false,"sendWhenFocused"\:false}' + LineEnding +
            'xpTracker.progressBarLabel=PERCENTAGE' + LineEnding +
            'agility.agilityArenaNotifier={"enabled"\:true,"initialized"\:false,"override"\:false,"tray"\:false,"volume"\:0,"timeout"\:0,"gameMessage"\:false,"sendWhenFocused"\:false}' + LineEnding +
            'itemCharge.showAbyssalBraceletCharges=true' + LineEnding +
            'barrows.showPuzzleAnswer=true' + LineEnding +
            'itemprices.showAlchProfit=false' + LineEnding +
            'blastfurnace.showCofferTime=true' + LineEnding +
            'raids.raidsTimer=true' + LineEnding +
            'groundMarker.borderWidth=2.0' + LineEnding +
            'puzzlesolver.displaySolution=true' + LineEnding +
            'prayer.prayerBarHideIfNonCombat=false' + LineEnding +
            'runelite.corpplugin=false' + LineEnding +
            'textrecolor.opaqueClanChatInfoHighlight=-65536' + LineEnding +
            'runelite.skillcalculatorplugin=false' + LineEnding +
            'keyremapping.cameraRemap=true' + LineEnding +
            'runelite.defaultworldplugin=false' + LineEnding +
            'fpscontrol.drawFps=true' + LineEnding +
            'fpscontrol.limitFps=false' + LineEnding +
            'randomevents.notifyAll={"enabled"\:false,"initialized"\:false,"override"\:false,"tray"\:false,"volume"\:0,"timeout"\:0,"gameMessage"\:false,"sendWhenFocused"\:false}' + LineEnding +
            'keyremapping.space=32\:0' + LineEnding +
            'zoom.relaxCameraPitch=false' + LineEnding +
            'prayer.prayerFlickLocation=NONE' + LineEnding +
            'grounditems.doubleTapDelay=250' + LineEnding +
            'implings.luckyColor=-10090651' + LineEnding +
            'runelite.panelToggleKey=123\:128' + LineEnding +
            'itemCharge.showPotionDoseCount=false' + LineEnding +
            'runelite.reportbuttonplugin=false' + LineEnding +
            'runelite.warningOnExit=LOGGED_IN' + LineEnding +
            'chatnotification.highlightOwnName=true' + LineEnding +
            'agility.highlightMarks=true' + LineEnding +
            'runecraft.showBlood=true' + LineEnding +
            'timers.showMagicImbue=true' + LineEnding +
            'playerindicators.highlightTeamMembers=ENABLED' + LineEnding +
            'wiki.leftClickSearch=false' + LineEnding +
            'grounditems.insaneValueColor=-39246' + LineEnding +
            'grandexchange.enableGeLimits=true' + LineEnding +
            'hiscore.menuOption=true' + LineEnding +
            'worldmap.scrollIcon=true' + LineEnding +
            'clanchat.joinLeaveRank=UNRANKED' + LineEnding +
            'poh.showDigsitePendant=true' + LineEnding +
            'menuentryswapper.swapTeleToPoh=false' + LineEnding +
            'herbiboar.showTunnel=true' + LineEnding +
            'tileindicators.highlightHoveredColor=0' + LineEnding +
            'itemidentification.showEnchantedJewellery=false' + LineEnding +
            'pyramidplunder.highlightContainersColor=-256' + LineEnding +
            'randomevents.notifyJekyll={"enabled"\:false,"initialized"\:false,"override"\:false,"tray"\:false,"volume"\:0,"timeout"\:0,"gameMessage"\:false,"sendWhenFocused"\:false}' + LineEnding +
            'grandexchange.notifyOnOfferComplete={"enabled"\:false,"initialized"\:false,"override"\:false,"tray"\:false,"volume"\:0,"timeout"\:0,"gameMessage"\:false,"sendWhenFocused"\:false}' + LineEnding +
            'itemidentification.showPotions=false' + LineEnding +
            'fishing.showNames=false' + LineEnding +
            'menuentryswapper.swapBones=false' + LineEnding +
            'agility.trapHighlight=-65536' + LineEnding +
            'implings.ninjaColor=-12106165' + LineEnding +
            'textrecolor.transparentClanGuestInfoHighlight=-65536' + LineEnding +
            'poh.showPortalNexus=true' + LineEnding +
            'clanchat.guestClanChatShowOnlineMemberCount=false' + LineEnding +
            'xpupdater.templeosrs=false' + LineEnding +
            'timers.showPrayerEnhance=true' + LineEnding +
            'screenshot.kingdom=true' + LineEnding +
            'runelite.notificationSound=NATIVE' + LineEnding +
            'metronome.tockVolume=0' + LineEnding +
            'entityhider.hidePlayers2D=true' + LineEnding +
            'itemidentification.identificationType=SHORT' + LineEnding +
            'slayer.infobox=true' + LineEnding +
            'objectindicators.highlightClickbox=false' + LineEnding +
            'tithefarmplugin.hexColorWatered=-16737793' + LineEnding +
            'randomevents.notifyMime={"enabled"\:false,"initialized"\:false,"override"\:false,"tray"\:false,"volume"\:0,"timeout"\:0,"gameMessage"\:false,"sendWhenFocused"\:false}' + LineEnding +
            'metronome.tickCount=1' + LineEnding +
            'runelite.implingsplugin=false' + LineEnding +
            'herbiboar.showObject=true' + LineEnding +
            'worldmap.rareTreeIcon=true' + LineEnding +
            'boosts.displayNextBuffChange=BOOSTED' + LineEnding +
            'runelite.mousehighlightplugin=false' + LineEnding +
            'runepouch.runePouchOverlayMode=BOTH' + LineEnding +
            'music.areaSoundEffectVolume=0' + LineEnding +
            'combatlevel.showLevelsUntil=true' + LineEnding +
            'idlenotifier.interactionidle={"enabled"\:true,"initialized"\:false,"override"\:false,"tray"\:false,"volume"\:0,"timeout"\:0,"gameMessage"\:false,"sendWhenFocused"\:false}' + LineEnding +
            'menuentryswapper.swapBirdhouseEmpty=true' + LineEnding +
            'entityhider.hideDeadNpcs=false' + LineEnding +
            'wintertodt.damageNotificationColor=-16711681' + LineEnding +
            'cluescroll.displayHintArrows=true' + LineEnding +
            'implings.showdragon=HIGHLIGHT' + LineEnding +
            'antiDrag.onShiftOnly=true' + LineEnding +
            'woodcutting.forestryBeeHiveNotification={"enabled"\:true,"initialized"\:false,"override"\:false,"tray"\:false,"volume"\:0,"timeout"\:0,"gameMessage"\:false,"sendWhenFocused"\:false}' + LineEnding +
            'itemCharge.showTeleportCharges=true' + LineEnding +
            'lowmemory.hideLowerPlanes=false' + LineEnding +
            'implings.showlucky=HIGHLIGHT' + LineEnding +
            'runecraft.showCosmic=true' + LineEnding +
            'runelite.cluescrollplugin=false' + LineEnding +
            'fishing.trawlerTimer=true' + LineEnding +
            'pyramidplunder.highlightedSarcophagusFloor=9' + LineEnding +
            'menuentryswapper.swapChase=true' + LineEnding +
            'menuentryswapper.groundItemShiftClickWalkHere=false' + LineEnding +
            'clanchat.recentChats=true' + LineEnding +
            'xpTracker.prioritizeRecentXpSkills=false' + LineEnding +
            'implings.showspawn=false' + LineEnding +
            'grounditems.itemHighlightMode=BOTH' + LineEnding +
            'nightmareZone.absorptioncoloroverthreshold=-256' + LineEnding +
            'entityhider.hideRandomEvents=false' + LineEnding +
            'randomevents.notifyFlippa={"enabled"\:false,"initialized"\:false,"override"\:false,"tray"\:false,"volume"\:0,"timeout"\:0,"gameMessage"\:false,"sendWhenFocused"\:false}' + LineEnding +
            'itemCharge.showSackCharges=true' + LineEnding +
            'keyremapping.down=83\:0' + LineEnding +
            'menuentryswapper.swapStairsLeftClick=CLIMB' + LineEnding +
            'timers.showGodWarsAltar=true' + LineEnding +
            'teamCapes.teamCapesOverlay=false' + LineEnding +
            'screenshot.clanDeath=false' + LineEnding +
            'entityhider.hideIgnores=false' + LineEnding +
            'runecraft.showChaos=true' + LineEnding +
            'loginscreen.syncusername=true' + LineEnding +
            'runelite.bankplugin=false' + LineEnding +
            'npcUnaggroArea.npcUnaggroShowAreaLines=false' + LineEnding +
            'runecraft.showWater=true' + LineEnding +
            'runelite.useWikiItemPrices=true' + LineEnding +
            'party.statusOverlayHealth=false' + LineEnding +
            'chatcommands.lp=true' + LineEnding +
            'itemCharge.showImpCharges=true' + LineEnding +
            'npcindicators.drawMinimapNames=false' + LineEnding +
            'statusbars.leftBarMode=HITPOINTS' + LineEnding +
            'dpscounter.bossDamage=false' + LineEnding +
            'runelite.itemchargeplugin=false' + LineEnding +
            'itemidentification.showTeleportScrolls=false' + LineEnding +
            'interacthighlight.outlineFeather=4' + LineEnding +
            'randomevents.notifyGravedigger={"enabled"\:false,"initialized"\:false,"override"\:false,"tray"\:false,"volume"\:0,"timeout"\:0,"gameMessage"\:false,"sendWhenFocused"\:false}' + LineEnding +
            'idlenotifier.hitpoints=1' + LineEnding +
            'menuentryswapper.swapTeleportItem=false' + LineEnding +
            'cannon.highlightDoubleHitColor=-65536' + LineEnding +
            'timetracking.timeFormatMode=ABSOLUTE_24H' + LineEnding +
            'objectindicators.outlineFeather=0' + LineEnding +
            'poh.showAltar=true' + LineEnding +
            'agility.stickHighlightColor=-65536' + LineEnding +
            'xpglobes.Progress\ orb\ background\ color=2139127936' + LineEnding +
            'woodcutting.clueNestNotifyTier=BEGINNER' + LineEnding +
            'runelite.dragHotkey=0\:0' + LineEnding +
            'bank.searchKeybind=70\:128' + LineEnding +
            'runelite.loginscreenplugin=false' + LineEnding +
            'npcUnaggroArea.npcAggroAreaColor=1694498560' + LineEnding +
            'discord.showRaidingActivity=true' + LineEnding +
            'randomevents.notifyGenie={"enabled"\:false,"initialized"\:false,"override"\:false,"tray"\:false,"volume"\:0,"timeout"\:0,"gameMessage"\:false,"sendWhenFocused"\:false}' + LineEnding +
            'npcUnaggroArea.showOnSlayerTask=false' + LineEnding +
            'xpglobes.alignOrbsVertically=false' + LineEnding +
            'itemCharge.slaughterNotification={"enabled"\:true,"initialized"\:false,"override"\:false,"tray"\:false,"volume"\:0,"timeout"\:0,"gameMessage"\:false,"sendWhenFocused"\:false}' + LineEnding +
            'runelite.itemstatplugin=false' + LineEnding +
            'nightmareZone.powersurgenotification={"enabled"\:false,"initialized"\:false,"override"\:false,"tray"\:false,"volume"\:0,"timeout"\:0,"gameMessage"\:false,"sendWhenFocused"\:false}' + LineEnding +
            'itemidentification.showFruitTreeSeeds=false' + LineEnding +
            'tileindicators.currentTileBorderWidth=2.0' + LineEnding +
            'timers.showCharge=true' + LineEnding +
            'menuentryswapper.npcLeftClickCustomization=true' + LineEnding +
            'xpTracker.hideMaxed=false' + LineEnding +
            'runelite.containInScreen2=RESIZING' + LineEnding +
            'textrecolor.opaquePublicChatHighlight=-16777216' + LineEnding +
            'interacthighlight.objectShowHover=true' + LineEnding +
            'runelite.notificationGameMessage=false' + LineEnding +
            'grandexchange.showExact=false' + LineEnding +
            'raids.pointsMessage=true' + LineEnding +
            'keyremapping.fkeyRemap=false' + LineEnding +
            'grounditems.lowValuePrice=20000' + LineEnding +
            'randomevents.notifyBeekeeper={"enabled"\:false,"initialized"\:false,"override"\:false,"tray"\:false,"volume"\:0,"timeout"\:0,"gameMessage"\:false,"sendWhenFocused"\:false}' + LineEnding +
            'agility.highlightSepulchreObstacles=true' + LineEnding +
            'stretchedmode.increasedPerformance=false' + LineEnding +
            'xpTracker.resetSkillRateAfter=0' + LineEnding +
            'keyremapping.right=68\:0' + LineEnding +
            'grandexchange.showActivelyTradedPrice=true' + LineEnding +
            'customcursor.cursorStyle=RS3_GOLD' + LineEnding +
            'puzzlesolver.drawDots=false' + LineEnding +
            'worldhopper.ping=true' + LineEnding +
            'randomevents.notifyPrison={"enabled"\:false,"initialized"\:false,"override"\:false,"tray"\:false,"volume"\:0,"timeout"\:0,"gameMessage"\:false,"sendWhenFocused"\:false}' + LineEnding +
            'npcindicators.highlightTrueTile=false' + LineEnding +
            'puzzlesolver.displayRemainingMoves=true' + LineEnding +
            'randomevents.notifyDwarf={"enabled"\:false,"initialized"\:false,"override"\:false,"tray"\:false,"volume"\:0,"timeout"\:0,"gameMessage"\:false,"sendWhenFocused"\:false}' + LineEnding +
            'playerindicators.clanMenuIcons=true' + LineEnding +
            'agility.portalsHighlight=-65281' + LineEnding +
            'chatfilter.filterType=CENSOR_WORDS' + LineEnding +
            'bank.showHA=false' + LineEnding +
            'herbiboar.colorGameObject=-16711681' + LineEnding +
            'poh.showJewelleryBox=true' + LineEnding +
            'entityhider.hideFriends=false' + LineEnding +
            'cannon.lowWarningThreshold=0' + LineEnding +
            'boosts.displayPanel=false' + LineEnding +
            'chatcommands.pb=true' + LineEnding +
            'barbarianAssault.showHealerBars=true' + LineEnding +
            'herbiboar.colorStart=-16711681' + LineEnding +
            'textrecolor.opaqueExamineHighlight=-16776961' + LineEnding +
            'banktags.preventTagTabDrags=false' + LineEnding +
            'itemidentification.showSaplings=true' + LineEnding +
            'menuentryswapper.removeDeadNpcMenus=false' + LineEnding +
            'runelite.notesplugin=false' + LineEnding +
            'textrecolor.transparentClanChatMessageHighlight=-1' + LineEnding +
            'wintertodt.notifyEmptyInv=true' + LineEnding +
            'objectindicators.highlightHull=true' + LineEnding +
            'chatcommands.qp=true' + LineEnding +
            'bank.showGE=true' + LineEnding +
            'clanchat.confirmKicks=false' + LineEnding +
            'kingdomofmiscellania.approvalThreshold=100' + LineEnding +
            'runelite.poisonplugin=false' + LineEnding +
            'tearsofguthix.greenTearsColor=1677786880' + LineEnding +
            'party.pingHotkey=0\:0' + LineEnding +
            'menuentryswapper.swapEssenceMineTeleport=false' + LineEnding +
            'playerindicators.clanChatMemberColor=-14413909' + LineEnding +
            'itemidentification.showImplingJars=false' + LineEnding +
            'itemidentification.showJewellery=false' + LineEnding +
            'timers.showFreezes=true' + LineEnding +
            'pyramidplunder.timerLowWarning=30';
end;

procedure TWaspUpdater.InstallRLProfile(out name: String);
  function _StrToInt(str: String): Int32;
  var i: Int32;
  begin
    for i := 1 to Length(str) do Result += Int32(str[i]);
  end;
var
  path: String;
  json, tmp: TJSONObject;
  arr, clean: TJSONArray;
  i, j, id: Int32;
  updated: Boolean;
begin
  path := GetEnvironmentVariable('userprofile') + DirectorySeparator + '.runelite' + DirectorySeparator + 'profiles2' + DirectorySeparator ;

  name := WaspClient.Cache.User.ID;
  id :=  _StrToInt(name);
  name := name.SubString(0,8);

  if FileExists(path + name + '-' + ToStr(id) + '.properties') then
    if not DeleteFile(path + name + '-' + ToStr(id) + '.properties') then
      TerminateScript('Failed to delete RuneLite WaspScripts profile.');

  WriteFileContents(path + name + '-' + ToStr(id) + '.properties', Self.GetProfileFileString(), False);

  try
    json.Init(ReadFileContents(path + 'profiles.json'));
    arr := json.getJSONArray('profiles');

    j := -1;
    clean.Init();
    for i := 0 to arr.High() do
    begin
      tmp := arr.getJSONObject(i);
      if (tmp.getInt('id') = id) and (tmp.getString('name') = name) then
      begin
        tmp.Put('active', True);
        tmp.Put('sync', False);
        tmp.Put('rev', -1);
        tmp.remove('defaultForRsProfiles');
        clean.Put(tmp);
        j := clean.High();
        Continue;
      end;

      if (tmp.getInt('id') = id) then Continue;
      if (tmp.getString('name') = name) then Continue;
      if tmp.getBoolean('active') then tmp.Put('active', False);

      clean.Put(tmp);
    end;

    if j = -1 then
    begin
      tmp.Init('{"id":' + ToStr(id) + ',"name":"' + name + '","sync":false,"active":true,"rev":-1}');
      clean.put(tmp);
    end;

    json.remove('profiles');
    json.put('profiles', clean);

    if not WriteFileContents(path + 'profiles.json', json.toString(), False) then
      TerminateScript('Failed to write to profiles.json');
  finally
    json.Free();
  end;
end;

procedure TWaspUpdater.SelfUpdate();
begin
  Self.UpdateScript(WaspClient.Cache.Launcher);

  if FileExists(Self.ScriptsPath + 'wasp-launcher-by-torwent.simba') then
  begin
    if FileExists(Self.Launcher.Path) and not DeleteFile(Self.Launcher.Path) then
      TerminateScript('Failed to delete old launcher.');

    if not CopyFile(Self.ScriptsPath + 'wasp-launcher-by-torwent.simba', Self.Launcher.Path) then
      TerminateScript('Failed to copy updated launcher to it''s directory.');
  end;
end;

procedure TWaspUpdater.Free();
begin
  Self.MonitorSRLT.Timer.Free();
  Self.MonitorWL.Timer.Free();
end;

procedure TWaspUpdater.Setup();
begin
  Self.Name := 'WaspUpdater';
  Self.Launcher.ID := {$macro SCRIPT_ID};
  Self.Launcher.Revision := StrToIntDef({$macro SCRIPT_REVISION}, 1);

  Self.Launcher.Path := ScriptPath + 'wasp-launcher.simba';
  Self.ScriptsPath := ScriptPath + 'waspscripts.com' + DirectorySeparator;

  if not ForceDirectories(Self.ScriptsPath) then
    TerminateScript('WaspUpdater can''t create scripts directory.');;

  Self.MonitorSRLT.Package := 'srl-t';
  Self.MonitorSRLT.Timer.Init(nil);
  Self.MonitorSRLT.Timer.setName('srlt_update_monitor');
  Self.MonitorSRLT.Timer.setInterval(200);

  Self.MonitorWL.Package := 'wasplib';
  Self.MonitorWL.Timer.Init(nil);
  Self.MonitorWL.Timer.setName('srlt_update_monitor');
  Self.MonitorWL.Timer.setInterval(200);

  AddOnTerminate(@Self.Free);
end;



{$IFNDEF WS_FORM_INCLUDED}         
{$DEFINE WS_FORM_INCLUDED}


(*
# WaspForm
Frontend form for the {ref}`WaspClient`.
*)
type
  TWaspForm = record
    Form: TForm;
    Size: TPoint;
    ServerListener: TTimer;
    Updating: record
      SRL: Boolean;
      WaspLib: Boolean;
      Script: Boolean;
    end;
  end;

procedure TWaspForm.HandleLogin(loginPanel: TPanel);
var
  msPanel, dPanel: TPanel;
  id, user: TLabel;
  pass: TEdit;
  scripts: TScriptDataArray;
  listBox: TListBox;
  i, idx: Int32;
begin
  if WaspUpdater.Launcher.Revision < WaspClient.Cache.Launcher.Revision then
  begin
    WaspUpdater.SelfUpdate();
    SimbaCloseCurrentTab();
    WriteLn(LineEnding + LineEnding + LineEnding + LineEnding + 'Wasp Launcher has been updated. Please run it again!' + LineEnding + LineEnding + LineEnding + LineEnding);
    Self.Form.Close();
    TerminateScript();
  end;

  pass := loginPanel.GetChild('password_edit');
  pass.Clear();

  msPanel := Self.Form.GetChild('main_panel');
  dPanel := Self.Form.GetChild('discord_panel');

  user := msPanel.GetChild('user_label');
  id := msPanel.GetChild('id_label');

  user.setCaption('Logged as: ' + WaspClient.Cache.User.Username);
  id.setCaption('ID: ' + WaspClient.Cache.User.Id);

  WaspClient.ApplyNoSubPremiumType();

  scripts := WaspClient.GetAllUserScripts();

  listBox := msPanel.GetChild('scripts_listbox');

  listBox.Clear();
  idx := -1;
  for i := 0 to High(scripts) do
  begin
    listBox.getItems().Add(scripts[i].Name);
    if scripts[i].ID = LauncherConfig.GetString('last_script') then
      idx := i;
  end;

  if idx = -1 then
  begin
    listbox.setItemIndex(0);
    LauncherConfig.Remove('last_script');
  end
  else
    listbox.setItemIndex(0);

  msPanel.Show();
  loginPanel.Hide();
  dPanel.Hide();
  Self._OnScriptChange(listBox);
end;

procedure TWaspForm.HandleLogout(msPanel: TPanel);
var
  loginPanel: TPanel;
begin
  loginPanel := Self.Form.GetChild('login_panel');

  if LauncherConfig.GetBoolean('use_discord') then
    Self._DiscordButton(loginPanel.GetChild('discord_button'))
  else
    loginPanel.Show();
  msPanel.Hide();
end;


procedure TWaspForm._OpenScript(sender: TObject);
var
  list: TListBox;
  script: TScriptData;
  scriptFile: TScriptFile;
begin
  list := sender;
  script := WaspClient.GetAllUserScripts()[list.getItemIndex()];
  LauncherConfig.Put('last_script', script.ID);
  scriptFile := WaspUpdater.GetScriptFile(script.ID);
  SimbaOpenInTab(scriptFile.Path);
  Self.Form.Close();
end;

procedure TWaspForm._OpenScriptEx(sender: TObject);
var
  panel: TPanel;
begin
  panel := TButton(sender).getOwner();
  Self._OpenScript(panel.GetChild('scripts_listbox'));
end;


procedure TWaspForm._InstallProfile(sender: TObject);
var
  name: String;
begin
  WaspUpdater.InstallRLProfile(name);
  MessageDlg('WaspScripts', 'RuneLite profile installed! Please pick "' + name + '" profile before you start botting.', TMsgDlgType.mtInformation, []);
end;

procedure TWaspForm._MailField(sender: TObject; var key: char);
var
  panel: TPanel;
  email, password: TEdit;
  button: TButton;
  strMail: String;
begin
  email := sender;
  panel := email.getOwner().getOwner();
  button := panel.GetChild('login_button');
  password := panel.GetChild('password_edit');
  strMail := email.getText();
  button.setEnabled(strMail.IsEmail() and (password.GetTextLen() > 4));

  case key of
    ' ': key := #0;
    #13: TEdit(sender).PerformTab(True);
  end;
end;

procedure TWaspForm._PasswordField(sender: TObject; var key: char); overload;
var
  panel: TPanel;
  email: TEdit;
  button: TButton;
  strMail: String;
begin
  panel := TEdit(sender).getOwner().getOwner();
  button := panel.GetChild('login_button');
  email := panel.GetChild('email_edit');
  strMail := email.getText();
  button.setEnabled(strMail.IsEmail() and (TEdit(sender).GetTextLen() > 4));

  case key of
    ' ': key := #0;
    #13: TEdit(sender).PerformTab(True);
  end;
end;


procedure TWaspForm._UpdateSRL();
var
  panel: TPanel;
  caption, button: TComponent;
begin
  panel := Self.Form.GetChild('current_version_panel');
  caption := panel.GetChild('current_srl_label');
  panel := panel.GetOwner();
  button := panel.GetChild('update_srl_button');
  WaspUpdater.Update('srlt', caption, button);
end;

procedure TWaspForm._UpdateWL();
var
  panel: TPanel;
  caption, button: TComponent;
begin
  panel := Self.Form.GetChild('current_version_panel');
  caption := panel.GetChild('current_wl_label');

  panel := panel.GetOwner();
  button := panel.GetChild('update_wl_button');

  WaspUpdater.Update('wasplib', caption, button);
end;

procedure TWaspForm._UpdateScript();
var
  list: TListBox;
  script: TScriptData;
begin
  try
    Self.Updating.Script := True;
    list := Self.Form.GetChild('scripts_listbox');
    script := WaspClient.GetAllUserScripts()[list.getItemIndex()];

    if WaspClient.GetUnsubscribedScripts().Find(script.ID) > -1 then
      OpenWebPage("https://waspscripts.com/scripts/" + script.URL)
    else
      WaspUpdater.UpdateScript(script);

    Self._OnScriptChange(list);
  finally
    Self.Updating.Script := False;
  end;
end;

procedure TWaspForm._UpdateScripts(sender: TObject);
var
  list: TListBox;
  data: TScriptDataArray;
  script: TScriptData;
  idx, i: Int32;
begin
  list := Self.Form.GetChild('scripts_listbox');
  data := WaspClient.GetAllUserScripts();

  for i := 0 to list.getItems().getCount()-1 do
  begin
    try
      Self.Updating.Script := True;
      WaspUpdater.UpdateScript(data[i]);
    finally
      Self.Updating.Script := False;
    end;
  end;

  Self._OnScriptChange(list);
end;


procedure TWaspForm._OnTogglePass(sender: TObject);
var
  panel: TPanel;
  edit: TEdit;
  caption: TLabel;
  checkbox: TCheckBox;
begin
  checkbox := sender;
  panel   := checkbox.getParent();
  caption := panel.GetComponent(0);
  panel := panel.getParent();
  edit    := panel.GetChild('password_edit');

  if checkbox.IsChecked() then
  begin
    caption.setCaption('Hide password');
    edit.setPasswordChar(#0);
    Exit;
  end;

  caption.setCaption('Show password');
  edit.setPasswordChar('*');
end;


procedure TWaspForm._OnScriptChange(sender: TObject);
var
  list: TListBox;
  main, panel: TPanel;
  text: TLabel;
  memo: TMemo;
  update, open: TButton;
  checkbox: TCheckBox;
  scriptData: TScriptData;
  scriptFile: TScriptFile;
begin
  list := sender;
  list.Repaint();

  scriptData := WaspClient.GetAllUserScripts()[list.getItemIndex()];
  scriptFile := WaspUpdater.GetScriptFile(scriptData.ID);

  main := list.getOwner().getOwner().getOwner().getOwner();

  panel := main.GetChild('version_panel');

  text := panel.GetChild('current_script_label');
  if scriptFile.Revision = 0 then
    text.setCaption('')
  else
    text.setCaption('rev.' + ToStr(scriptFile.Revision));

  if scriptFile.Revision <> scriptData.Revision then
    text.SetFontColor($1800E9)
  else
    text.SetFontColor($18E982);

  text := panel.GetChild('latest_script_label');
  text.setCaption('rev.' + ToStr(scriptData.Revision));

  if scriptFile.Revision <> scriptData.Revision then
    text.SetFontColor($1800E9)
  else
    text.SetFontColor($18E982);

  update := panel.GetChild('update_script_button');

  if scriptData.Typ = EScriptType.PREMIUM_NO_SUB then
    update.setCaption('Purchase')
  else
    case scriptFile.Revision of
      0: update.setCaption('Install');
      scriptData.Revision: update.setCaption('Re-install');
      else update.setCaption('Update');
    end;

  open  := main.GetChild('script_open_button');
  open.setEnabled(scriptFile.Revision <> 0);

  checkbox := panel.GetChild('update_script_checkbox');

  if scriptData.Typ = EScriptType.PREMIUM_NO_SUB then
    checkbox.SetChecked(False)
  else
    checkbox.SetChecked(LauncherConfig.GetBoolean('update_' + scriptData.ID));

  if checkbox.IsChecked() and (scriptFile.Revision <> scriptData.Revision) then
  begin
    WaspUpdater.UpdateScript(scriptData);
    Self._OnScriptChange(sender);
    Exit;
  end;

  panel := main.GetChild('script_panel');
  text := panel.GetChild('script_name_label');
  text.setCaption(scriptData.Name);

  text := panel.GetChild('script_category_label');
  case scriptData.Typ of
    EScriptType.PREMIUM:
    begin
      text.setCaption('Premium');
      text.SetFontColor($4DB5FF);
    end;
    EScriptType.FREE:
    begin
      text.setCaption('Free');
      text.SetFontColor($F0F0F0);
    end;
    EScriptType.PREMIUM_NO_SUB:
    begin
      text.setCaption('Premium - Not owned');
      text.SetFontColor($FFFF00);
    end;
  end;
  text.setLeft(panel.getWidth() - text.GetTrueWidth() - TControl.AdjustToDPI(5));

  memo := panel.GetChild('script_content_memo');
  memo.setText(scriptData.Description + LineEnding + LineEnding + scriptData.Content);

  if not FileExists(WaspClient.AssetsPath + scriptData.ID + DirectorySeparator + 'banner.jpg') then
    WaspClient.DownloadImage(scriptData.ID, 'banner');

  panel.SwapImage(WaspClient.AssetsPath + scriptData.ID + DirectorySeparator + 'banner.jpg');
end;

procedure TWaspForm._OnScriptOnKeyDown(sender: TObject; var key: Char);
var
  panel: TPanel;
  edit: TEdit;
  str: String;
  tmp: Char;
begin
  tmp := key;
  key := #0;

  case tmp of
    ' ': Self._UpdateScript();
    #13: Self._OpenScript(sender);
  end;

  panel := TControl(sender).getParent().getParent().getParent().getParent();
  edit := panel.GetChild('search_edit');
  str := edit.getText();
  if tmp = #08 then
  begin
    SetLength(str, Length(str)-1);
    edit.setText(str);
    Exit;
  end;

  edit.setText(str + tmp);
end;

procedure TWaspForm._OnScriptSearchChange(sender: TObject);
var
  parent: TControl;
  list: TListBox;
  edit: TEdit;
  query: String;
  i: Int32;
begin
  parent := TControl(sender).getParent();
  while parent.getName() <> 'scripts_panel' do parent := parent.getParent();

  list := parent.GetChild('scripts_listbox');
  edit := parent.GetChild('search_edit');

  query := LowerCase(Trim(edit.GetText()));
  if (query = '') then Exit;

  for i := 0 to list.getItems().getCount() - 1 do
    if list.getItems().getStrings(i).Lower().Contains(query) then
    begin
      list.setItemIndex(i);
      list.SetFocus();
      Self._OnScriptChange(list);
      Break;
    end;
end;


procedure TWaspForm.SetDarkTheme(sender: TWinControl);
var
  name: String;
begin
  name := sender.getName();
  if (name = '') or name.Contains('label') then Exit;

  if name.Contains('edit') then
    SetWindowTheme(sender.getHandle(), 'DarkMode_CFD')
  else
    SetWindowTheme(sender.getHandle(), 'DarkMode_Explorer');

  AllowDarkModeForWindow(sender.getHandle(), True);
end;

procedure TWaspForm.SetChildsDarkTheme(sender: TWinControl);
var
  i: Int32;
begin
  for i := 0 to sender.getComponentCount() - 1 do
    Self.SetChildsDarkTheme(sender.GetComponent(i));
  Self.SetDarkTheme(sender);
end;

procedure TWaspForm.SetAllChildsDarkTheme();
var
  i: Int32;
  child: TControl;
begin
  for i := 0 to Self.Form.getComponentCount() - 1 do
  begin
    child := Self.Form.GetComponent(i);
    Self.SetChildsDarkTheme(child);
  end;

  SetWindowTheme(Self.Form.getHandle(), 'DarkMode_Explorer');
  AllowDarkModeForWindow(Self.Form.getHandle(), True);
  RefreshImmersiveColorPolicyState();
  FlushMenuThemes();
end;


procedure TWaspForm.SetupDiscordPanel(form: TForm);
  type TWaspForm = TWaspForm;
  procedure TWaspForm._CancelButton(sender: TObject);
  var
    lPanel, dPanel: TPanel;
  begin
    LauncherConfig.Put('use_discord', False);
    dPanel := TButton(sender).getOwner();
    lPanel := Self.Form.GetChild('login_panel');
    lPanel.Show();
    dPanel.Hide();
    CloseFile(CreateFile(WaspAsync.Path + 'server-stop'));
    Self.ServerListener.setEnabled(False);
  end;

var
  panel: TPanel;
  cancel: TButton;
  caption, info: TLabel;
  h, w: Int32;
begin
  panel.Create(form);
  panel.setName('discord_panel');
  panel.setCaption('');
  panel.setWidth(TControl.AdjustToDPI(600));
  panel.setHeight(TControl.AdjustToDPI(300));

  h := panel.getHeight() div 2;
  w := panel.getWidth() div 2;

  panel.SetLeft(Self.Size.X div 2 - w);
  panel.SetTop(Self.Size.Y div 2 - (panel.getHeight() - (panel.getHeight() div 10)));
  panel.setBevelWidth(0);
  panel.Hide();

  caption.Create(panel);
  caption.SetName('discord_label');
  caption.SetTop(h);
  caption.SetFontSize(32);
  caption.SetCaption('Sign In On Your Browser');
  caption.SetLeft(w - caption.GetTrueWidth() div 2);

  info.Create(panel);
  info.SetName('discord_info_label');
  info.SetTop(h + h div 3);
  info.SetCaption('This page will refresh once you''re signed in.');
  info.SetLeft(w - info.GetTrueWidth() div 2);

  cancel.Create(panel);
  cancel.SetName('cancel_button');
  cancel.SetCaption('Cancel');
  cancel.setWidth(panel.getWidth() div 3);
  cancel.SetLeft(w - cancel.getWidth() div 2);
  cancel.SetTop(info.getTop() + info.getHeight() + TControl.AdjustToDPI(20));
  cancel.setOnClick(@Self._CancelButton);
end;



procedure TWaspForm._LogoutButton(sender: TObject);
begin
  if WaspClient.Logout() then
    Self.HandleLogout(TButton(sender).getParent().getParent());
end;



procedure TWaspForm._OnListen(sender: TObject);
var
  token: String;
  i: Int32;
  {$IFDEF DEVELOPER_MODE}t: Double;{$ENDIF}
begin
  {$IFDEF DEVELOPER_MODE}t := PerformanceTimer();{$ENDIF}
  if FileExists(WaspAsync.Path + 'server-failed.done') then
  begin
    DeleteFile(WaspAsync.Path + 'server-failed.done');
    TTimer(sender).setEnabled(False);
    Self._CancelButton(Self.Form.GetChild('cancel_button'));
    Exit;
  end;

  if not FileExists(WaspAsync.Path + 'server-success.done') then Exit;

  token := ReadFileContents(WaspAsync.Path + 'server-success.done');
  DeleteFile(WaspAsync.Path + 'server-success.done');
  TTimer(sender).setEnabled(False);
  CloseFile(CreateFile(WaspAsync.Path + 'server-stop'));

  if (token <> '') and WaspClient.FinishOAuth2Login(token) then
  begin
    Self.HandleLogin(Self.Form.GetChild('login_panel'));
    {$IFDEF DEVELOPER_MODE}
    WriteLn('Full login took: ', Round(PerformanceTimer()-t, 4), 'ms.');
    {$ENDIF}
    Exit;
  end;
end;

procedure TWaspForm.Listen();
begin
  Self.ServerListener.setOnTimer(@Self._OnListen);
  Self.ServerListener.setEnabled(True);
end;

procedure TWaspForm.SetupLoginPanel(form: TForm);
  type TWaspForm = TWaspForm;

  procedure TWaspForm._LoginButton(sender: TObject);
  var
    loginPanel, msPanel: TPanel;
    email, password: TEdit;
    {$IFDEF DEVELOPER_MODE}
    t: Double;
    {$ENDIF}
  begin
    {$IFDEF DEVELOPER_MODE}
    t := PerformanceTimer();
    {$ENDIF}

    loginPanel := TComponent(sender).getOwner();
    msPanel := Self.Form.GetChild('main_panel');

    email := loginPanel.GetChild('email_edit');
    password := loginPanel.GetChild('password_edit');

    if WaspClient.Login(email.getText(), password.getText()) then
    begin
      Self.HandleLogin(loginPanel);
      {$IFDEF DEVELOPER_MODE}
      WriteLn('Full login took: ', Round(PerformanceTimer()-t, 4), 'ms.');
      {$ENDIF}
      Exit;
    end;

    with email.getFont() do
    begin
      setColor($0000FF);
      setStyle([]);
    end;

    with password.getFont() do
    begin
      setColor($0000FF);
      setStyle([]);
    end;
  end;

  procedure TWaspForm._Validate(edit: TEdit);
  var
    panel: TPanel;
    email, password: TEdit;
    strMail: String;
    button: TButton;
  begin
    panel := edit.getOwner().getOwner();

    case edit.getName() of
      'email_edit':
      begin
        email := edit;
        password := panel.GetChild('password_edit');
      end;
      'password_edit':
      begin
        email := panel.GetChild('email_edit');
        password := edit;
      end;
      else
        TerminateScript('TWaspForm._Validate(), unknown control.');
    end;

    with email.getFont() do
    begin
      setStyle([fsBold]);
      setColor($F0F0F0);
    end;

    with password.getFont() do
    begin
      setStyle([fsBold]);
      setColor($F0F0F0);
    end;

    strMail := email.getText();
    button := TButton(panel.GetChild('login_button'));
    button.setEnabled(strMail.IsEmail() and (password.GetTextLen() > 4));

    if button.IsEnabled() then
      Self._LoginButton(button);
  end;

  procedure TWaspForm._OnEmailDone(sender: TObject);
  var
    email: TEdit;
    str: String;
  begin
    Self._Validate(sender);
    email := sender;
    str := LowerCase(Trim(email.getText()));
    if str.IsEmail() then
      LauncherConfig.Put('email', LowerCase(Trim(email.getText())));
  end;

  procedure TWaspForm._OnEmailChange(sender: TObject);
  begin
    Self._OnEmailDone(sender);
  end;

  procedure TWaspForm._OnPassDone(sender: TObject);
  begin
    Self._Validate(sender);
  end;

  procedure TWaspForm._OnPassChange(sender: TObject);
  begin
    Self._OnPassDone(sender);
  end;

  procedure TWaspForm._DiscordButton(sender: TObject);
  var
    lPanel, dPanel: TPanel;
  begin
    LauncherConfig.Put('use_discord', True);
    lPanel := TButton(sender).getOwner();

    dPanel := Self.Form.GetChild('discord_panel');

    dPanel.Show();
    lPanel.Hide();

    WaspClient.StartOAuth2Login();
    DeleteFile(WaspAsync.Path + 'server-failed.done');
    DeleteFile(WaspAsync.Path + 'server-success.done');
    RunScript(WaspAsync.Path + 'server.simba', ['LauncherPID=' + ToString(GetProcessID())]);
    Sync(@Self.Listen);
  end;
var
  panel: TPanel;
  mailEdit, passEdit: TLabeledEdit;
  login, discord: TButton;
  email: String;
  viewPass: TLabeledCheckBox;
begin
  panel.Create(form);
  panel.setName('login_panel');
  panel.setCaption('');
  panel.setWidth(TControl.AdjustToDPI(300));
  panel.setHeight(TControl.AdjustToDPI(180));
  panel.SetLeft(Self.Size.X div 2 - panel.getWidth() div 2);
  panel.SetTop(Self.Size.Y div 2 - (panel.getHeight() - (panel.getHeight() div 10)));
  panel.setBevelWidth(0);

  email := LauncherConfig.GetString('email');
  if email = '' then
    email := 'email@mail.com';

  mailEdit.Create(panel);
  mailEdit.SetName('email');
  mailEdit.SetCaption('Email');
  mailEdit.SetWidth(panel.getWidth());
  mailEdit.SetText(email);
  mailEdit.SetControlColor($303030);
  mailEdit.setControlFontColor($F0F0F0);
  mailEdit.Edit.setOnKeyPress(@Self._MailField);
  mailEdit.Edit.setOnEditingDone(@Self._OnEmailDone);

  passEdit.Create(panel);
  passEdit.SetName('password');
  passEdit.SetCaption('Password');
  passEdit.SetTop(TControl.AdjustToDPI(50));
  passEdit.SetWidth(panel.getWidth());
  passEdit.SetControlColor($303030);
  passEdit.setControlFontColor($F0F0F0);
  passEdit.setPasswordChar('*');
  passEdit.Edit.setOnKeyPress(@Self._PasswordField);
  passEdit.Edit.setOnEditingDone(@Self._OnPassDone);
  passEdit.Edit.setOnChange(@Self._OnPassChange);

  viewPass.Create(panel);
  viewPass.SetName('viewpass');
  viewPass.SetCaption('Show password');
  viewPass.SetLeft(TControl.AdjustToDPI(10));
  viewPass.SetTop(TControl.AdjustToDPI(100));
  viewPass.CheckBox.setOnChange(@Self._OnTogglePass);

  Self._OnTogglePass(viewPass.CheckBox);

  login.Create(panel);
  login.SetName('login_button');
  login.SetCaption('Login');
  login.setWidth(panel.getWidth() div 3);
  login.SetTop(panel.getHeight() - (panel.getHeight() div 4));
  login.setEnabled(False);
  login.setOnClick(@Self._LoginButton);

  discord.Create(panel);
  discord.SetName('discord_button');
  discord.SetCaption('Discord login');
  discord.setWidth(login.getWidth());
  discord.SetLeft(panel.getWidth() - discord.getWidth());
  discord.SetTop(login.GetTop());
  discord.setOnClick(@Self._DiscordButton);
end;


procedure TWaspForm.SetupVersionsPanel(parent: TPanel; top: Int32);
  type TWaspForm = TWaspForm;

  function TWaspForm._VersionsTitleLabel(parent: TPanel; name: String; left: Int32): TPanel;
  var
    textLabel: TLabel;
  begin
    Result.Create(parent);
    Result.setName(LowerCase(name) + '_version_title_panel');
    Result.setCaption('');
    Result.setWidth(TControl.AdjustToDPI(110));
    Result.setHeight(parent.GetHeight());
    Result.SetLeft(left);
    Result.setBevelWidth(0);

    textLabel.Create(Result);
    textLabel.setName(LowerCase(name) + '_srl_title_label');
    textLabel.setCaption(name + ' SRL-T:');
    textLabel.setLeft(TControl.AdjustToDPI(3));
    textLabel.SetFontSize(10);
    textLabel.SetFontQuality(TFontQuality.fqCleartype);

    textLabel.Create(Result);
    textLabel.setName(LowerCase(name) + '_wl_title_label');
    textLabel.setCaption(name + ' WaspLib:');
    textLabel.setLeft(TControl.AdjustToDPI(3));
    textLabel.SetTop(TControl.AdjustToDPI(23));
    textLabel.SetFontSize(10);
    textLabel.SetFontQuality(TFontQuality.fqCleartype);

    textLabel.Create(Result);
    textLabel.setName(LowerCase(name) + '_script_title_label');
    textLabel.setCaption(name + ' Script:');
    textLabel.setLeft(TControl.AdjustToDPI(3));
    textLabel.SetTop(TControl.AdjustToDPI(46));
    textLabel.SetFontSize(10);
    textLabel.SetFontQuality(TFontQuality.fqCleartype);
  end;

  function TWaspForm._VersionsLabel(parent: TPanel; name, srlt, wl: String; left: Int32): TPanel;
  var
    textLabel: TLabel;
  begin
    Result.Create(parent);
    Result.setName(name + '_version_panel');
    Result.setCaption('');
    if name = 'current' then
      Result.setWidth(TControl.AdjustToDPI(90))
    else
      Result.setWidth(TControl.AdjustToDPI(70));
    Result.setHeight(parent.GetHeight());
    Result.SetLeft(left);
    Result.setBevelWidth(0);

    textLabel.Create(Result);
    textLabel.setName(name + '_srl_label');
    if srlt = '' then
      textLabel.setCaption('Missing')
    else if srlt = 'failed' then
      textLabel.setCaption('Rate limited')
    else
      textLabel.setCaption('v.' + srlt);
    textLabel.setLeft(TControl.AdjustToDPI(3));
    textLabel.SetFontSize(10);
    if srlt <> GitHubClient.Packages.Latest.SRLT then
      textLabel.SetFontColor($1800E9)
    else
      textLabel.SetFontColor($18E982);

    textLabel.Create(Result);
    textLabel.setName(name + '_wl_label');

    if wl = '' then
      textLabel.setCaption('Missing')
    else if wl = 'failed' then
      textLabel.setCaption('Rate limited')
    else
      textLabel.setCaption('v.' + wl);

    textLabel.setLeft(TControl.AdjustToDPI(3));
    textLabel.SetTop(TControl.AdjustToDPI(23));
    textLabel.SetFontSize(10);
    if wl <> GitHubClient.Packages.Latest.WaspLib then
      textLabel.SetFontColor($1800E9)
    else
      textLabel.SetFontColor($18E982);

    textLabel.Create(Result);
    textLabel.setName(name + '_script_label');
    textLabel.setLeft(TControl.AdjustToDPI(3));
    textLabel.SetTop(TControl.AdjustToDPI(46));
    textLabel.SetFontSize(10);
  end;

  function TWaspForm._VersionsControls(parent: TPanel; left: Int32): TPanel;
    type TWaspForm = TWaspForm;
    procedure TWaspForm._UpdateButton(sender: TObject);
    begin
      case TButton(sender).getName() of
        'update_srl_button':    {$IFNDEF DEVELOPER_MODE}Sync(@Self._UpdateSRL){$ENDIF};
        'update_wl_button':     {$IFNDEF DEVELOPER_MODE}Sync(@Self._UpdateWL){$ENDIF};
        'update_script_button': Self._UpdateScript();
      end;
    end;

    procedure TWaspForm._AutoUpdateToggle(sender: TObject);
    var
      panel: TPanel;
      button: TButton;
      list: TListBox;
      script: TScriptData;
    begin

      with TCheckBox(sender) do
        case GetName() of
          'update_script_checkbox':
          begin
            list := Self.Form.GetChild('scripts_listbox');
            script := WaspClient.GetAllUserScripts()[list.getItemIndex()];
            if script.Typ = EScriptType.PREMIUM_NO_SUB then
              SetChecked(False);

            LauncherConfig.Put('update_' + script.ID, IsChecked());
          end;

          else
          begin
            LauncherConfig.Put(GetName(), IsChecked());
            panel := TCheckBox(sender).getParent().getParent();
            button := panel.GetChild(GetName().Replace('checkbox', 'button'));
            {$IFNDEF DEVELOPER_MODE}
            if IsChecked() and (button.getCaption() <> 'Re-install') then
              Self._UpdateButton(button);
            {$ENDIF}
          end;
        end;
    end;

  var
    button: TButton;
    check: TLabeledCheckBox;
  begin
    Result.Create(parent);
    Result.setName('version_buttons_panel');
    Result.setCaption('');
    Result.SetLeft(left);
    Result.setWidth(TControl.AdjustToDPI(180));
    Result.setHeight(parent.GetHeight());
    Result.setBevelWidth(0);

    button.Create(Result);
    button.setName('update_srl_button');
    button.setLeft(TControl.AdjustToDPI(3));
    button.setHeight(TControl.AdjustToDPI(20));
    button.setWidth(TControl.AdjustToDPI(70));
    if GitHubClient.Packages.Current.SRLT <> GitHubClient.Packages.Latest.SRLT then
      button.setCaption('Update')
    else
      button.setCaption('Re-install');
    button.setOnClick(@Self._UpdateButton);

    button.Create(Result);
    button.setName('update_wl_button');
    button.setLeft(TControl.AdjustToDPI(3));
    button.SetTop(TControl.AdjustToDPI(23));
    button.setHeight(TControl.AdjustToDPI(20));
    button.setWidth(TControl.AdjustToDPI(70));
    if GitHubClient.Packages.Current.WaspLib <> GitHubClient.Packages.Latest.WaspLib then
      button.setCaption('Update')
    else
      button.setCaption('Re-install');
    button.setOnClick(@Self._UpdateButton);

    button.Create(Result);
    button.setName('update_script_button');
    button.setLeft(TControl.AdjustToDPI(3));
    button.SetTop(TControl.AdjustToDPI(46));
    button.setHeight(TControl.AdjustToDPI(20));
    button.setWidth(TControl.AdjustToDPI(70));
    if GitHubClient.Packages.Current.WaspLib <> GitHubClient.Packages.Latest.WaspLib then
      button.setCaption('Update')
    else
      button.setCaption('Re-install');
    button.setOnClick(@Self._UpdateButton);

    check.Create(Result);
    check.SetName('update_srl');
    check.SetCaption('Auto-update');
    check.setLeft(TControl.AdjustToDPI(90));
    check.SetTop(TControl.AdjustToDPI(2));
    if LauncherConfig.GetBoolean('update_srl_checkbox') then
      check.SetChecked(True);
    check.CheckBox.setOnChange(@Self._AutoUpdateToggle);
    Self._AutoUpdateToggle(check.CheckBox);

    check.Create(Result);
    check.SetName('update_wl');
    check.SetCaption('Auto-update');
    check.SetLeft(TControl.AdjustToDPI(90));
    check.SetTop(TControl.AdjustToDPI(25));
    if LauncherConfig.GetBoolean('update_wl_checkbox') then
      check.SetChecked(True);
    check.CheckBox.setOnChange(@Self._AutoUpdateToggle);
    Self._AutoUpdateToggle(check.CheckBox);

    check.Create(Result);
    check.SetName('update_script');
    check.SetCaption('Auto-update');
    check.SetLeft(TControl.AdjustToDPI(90));
    check.SetTop(TControl.AdjustToDPI(48));
    check.CheckBox.setOnChange(@Self._AutoUpdateToggle);
  end;

var
  panel, tmp: TPanel;
  w, h: Int32;
begin
  panel.Create(parent);
  panel.setName('version_panel');
  panel.setCaption('');
  panel.setAlign(TAlign.alCustom);
  panel.setBorderStyle(TFormBorderStyle.bsNone);
  panel.setBevelWidth(0);
  panel.SetTop(top);
  panel.setHeight(TControl.AdjustToDPI(70));

  tmp := Self._VersionsTitleLabel(panel, 'Current', 0);
  w := tmp.getWidth();
  h := tmp.getHeight();
  tmp := Self._VersionsLabel(panel, 'current', GitHubClient.Packages.Current.SRLT, GitHubClient.Packages.Current.WaspLib, w);
  w += tmp.getWidth();
  h += tmp.getHeight();

  tmp := Self._VersionsTitleLabel(panel, 'Latest', w);
  w += tmp.getWidth();
  h += tmp.getHeight();
  tmp := Self._VersionsLabel(panel, 'latest', GitHubClient.Packages.Latest.SRLT, GitHubClient.Packages.Latest.WaspLib, w);
  w += tmp.getWidth();
  h += tmp.getHeight();

  tmp := Self._VersionsControls(panel, w);
  w += tmp.getWidth();
  h += tmp.getHeight();
  panel.setWidth(w + 20);
  panel.setLeft(Self.Size.X - TControl.AdjustToDPI(40) - w);
end;

procedure TWaspForm.SetupScriptPanel(parent: TPanel; topLeft: TPoint);
var
  panel, memoInnerPanel, memoOutterPanel: TPanel;
  text: TLabel;
  memo: TMemo;
  img: TImage;
begin
  panel.Create(parent);
  panel.setName('script_panel');
  panel.setCaption('');
  panel.SetLeft(topLeft.X);
  panel.SetTop(topLeft.Y);
  panel.setWidth(Self.Size.X - topLeft.X - TControl.AdjustToDPI(40));
  panel.setHeight(Self.Size.Y - topLeft.Y - TControl.AdjustToDPI(80));
  panel.setBevelWidth(0);

  img.Create(panel);
  img.SetBounds(0, 0, panel.getWidth(), TControl.AdjustToDPI(140));
  img.SetStretch(True);
  img.SetName('image_null');

  text.Create(panel);
  text.setName('script_name_label');
  text.SetFontSize(10);
  text.SetFontStyle([TFontStyle.fsBold]);
  text.setLeft(TControl.AdjustToDPI(5));
  text.SetTop(TControl.AdjustToDPI(115));

  text.Create(panel);
  text.setName('script_category_label');
  text.setLeft(-TControl.AdjustToDPI(5));
  text.SetTop(TControl.AdjustToDPI(115));

  memoOutterPanel.Create(panel);
  memoOutterPanel.setName('script_omemo_panel');
  memoOutterPanel.setCaption('');
  memoOutterPanel.SetTop(TControl.AdjustToDPI(145));
  memoOutterPanel.setWidth(panel.getWidth());
  memoOutterPanel.setHeight(panel.getHeight() - memoOutterPanel.GetTop());
  memoOutterPanel.setBevelWidth(0);
  memoOutterPanel.setColor($505050);

  memoInnerPanel.Create(memoOutterPanel);
  memoInnerPanel.setName('script_imemo_panel');
  memoInnerPanel.setCaption('');
  memoInnerPanel.SetTop(TControl.AdjustToDPI(2));
  memoInnerPanel.SetLeft(TControl.AdjustToDPI(2));
  memoInnerPanel.setWidth(memoOutterPanel.getWidth() - TControl.AdjustToDPI(4));
  memoInnerPanel.setHeight(memoOutterPanel.getHeight() - TControl.AdjustToDPI(4));
  memoInnerPanel.setBevelWidth(0);
  memoInnerPanel.setColor($303030);

  memo.Create(memoInnerPanel);
  memo.setName('script_content_memo');
  memo.setLeft(-TControl.AdjustToDPI(2));
  memo.SetTop(-TControl.AdjustToDPI(2));
  memo.setWidth(memoInnerPanel.getWidth() + TControl.AdjustToDPI(4));
  memo.setHeight(memoInnerPanel.getHeight() + TControl.AdjustToDPI(4));
  memo.setColor($303030);
  memo.SetFontColor($D5D5D5);
  memo.setScrollBars(TScrollStyle.ssAutoBoth);
  memo.setReadOnly(True);
  memo.setHideSelection(True);
  memo.setWordWrap(True);
end;


procedure TWaspForm.OnDrawItem(control: TWinControl; idx: Integer; rect: TRect; state: TOwnerDrawState);
var
  listbox: TListBox;
  color, fColor: TColor;
begin
  listbox := control;
  if idx = listbox.getItemIndex() then color := $505050
  else if idx mod 2 = 0 then color := $303030
  else color := $282828;

  if WaspClient.GetAllUserScripts()[idx].Typ = EScriptType.PREMIUM then
    fColor := $4DB5FF
  else if WaspClient.GetAllUserScripts()[idx].Typ = EScriptType.PREMIUM_NO_SUB then
    fColor := $FFFF00
  else
    fColor := $F0F0F0;

  listbox.getCanvas().getBrush().setColor(color);
  listbox.getCanvas().FillRect(rect.Left, rect.Top, rect.Right, rect.Bottom);

  listbox.getCanvas().GetFont().setColor(fColor);
  listbox.getCanvas().getFont().setStyle([TFontStyle.fsBold]);
  listbox.getCanvas().TextRect(rect, 2, rect.Top+2, listbox.getItems().getStrings(idx));
end;


procedure TWaspForm._PanelSwapClick(sender: TObject);
var
  parent, extra, scripts: TPanel;
begin
  parent := TButton(sender).getParent();
  parent := parent.getParent();

  scripts := parent.GetChild('scripts_panel');
  extra := parent.GetChild('extra_panel');


  scripts.setVisible(not scripts.getVisible());
  scripts.setEnabled(not scripts.getEnabled());
  extra.setEnabled(not extra.getEnabled());
  extra.setVisible(not extra.getVisible());
end;

procedure TWaspForm._ClearCache(sender: TObject);
begin
  RMDir(SIMBA_DATA_DIR + 'cache');
  RMDir(SIMBA_DATA_DIR + 'WaspLib');
  RMDir(SIMBA_DATA_DIR + 'wasp-launcher' + DirectorySeparator + 'assets');
  RMDir(SIMBA_DATA_DIR + 'wasp-launcher' + DirectorySeparator + 'downloads');
end;

procedure TWaspForm.SetupScriptsPanel(parent: TPanel);
  type TWaspForm = TWaspForm;

  procedure TWaspForm._OnUserClick(sender: TObject);
  begin
    case TLabel(sender).getName() of
      'user_label': OpenWebPage('https://waspscripts.com/user/' + WaspClient.Cache.User.Id);
      'id_label': SetClipBoard(WaspClient.Cache.User.Id);
    end;
  end;

var
  panel: TPanel;
  user, id, launcherRev: TLabel;
  button: TButton;
  scriptsList: TLabeledDarkListBox;
  search: TLabeledEdit;
begin
  panel.Create(parent);
  panel.setName('scripts_panel');
  panel.setCaption('');
  panel.setWidth(Self.Size.X);
  panel.setHeight(Self.Size.Y);
  panel.setBevelWidth(0);

  user.Create(panel);
  user.setName('user_label');
  user.setCaption('');
  user.setLeft(TControl.AdjustToDPI(10));
  user.SetTop(TControl.AdjustToDPI(20));
  user.SetFontSize(12);
  user.setHint('Click to open your user profile.');
  user.setShowHint(True);
  user.setOnClick(@Self._OnUserClick);

  id.Create(panel);
  id.setName('id_label');
  id.setCaption('');
  id.setLeft(user.getLeft());
  id.SetTop(user.GetTop() + user.GetTrueHeight() + TControl.AdjustToDPI(20));
  id.SetFontSize(10);
  id.setHint('Click to copy the ID to the clipboard.');
  id.setShowHint(True);
  id.setOnClick(@Self._OnUserClick);

  scriptsList.Create(panel);
  scriptsList.SetName('scripts');
  scriptsList.SetCaption('Scripts:');
  scriptsList.SetLeft(id.getLeft());
  scriptsList.SetTop(id.GetTop() + id.getHeight() + TControl.AdjustToDPI(15));
  scriptsList.SetWidth(TControl.AdjustToDPI(260));
  scriptsList.setHeight(Self.Size.Y - scriptsList.GetTop() - TControl.AdjustToDPI(130));
  scriptsList.ListBox.ListBox.setOnClick(@Self._OnScriptChange);
  scriptsList.ListBox.ListBox.setOnKeyPress(@Self._OnScriptOnKeyDown);
  scriptsList.ListBox.ListBox.setStyle(TListBoxStyle.lbOwnerDrawFixed);
  scriptsList.ListBox.ListBox.setOnDrawItem(@Self.OnDrawItem);
  scriptsList.ListBox.ListBox.setColor($242322);

  search.Create(panel);
  search.SetCaption('Search');
  search.SetTop(scriptsList.GetBottom() + TControl.AdjustToDPI(5));
  search.SetLeft(id.getLeft());
  search.SetHeight(TControl.AdjustToDPI(40));
  search.SetWidth(TControl.AdjustToDPI(260));
  search.SetName('search');
  search.SetControlColor($303030);
  search.setControlFontColor($F0F0F0);
  search.Edit.setOnChange(@Self._OnScriptSearchChange);

  button.Create(panel);
  button.setName('extra_button');
  button.setCaption('Extra settings');
  button.SetTop(panel.getHeight() - TControl.AdjustToDPI(70));
  button.setLeft(TControl.AdjustToDPI(10));
  button.setWidth(TControl.AdjustToDPI(150));
  button.setHeight(TControl.AdjustToDPI(30));
  button.setOnClick(@Self._PanelSwapClick);

  button.Create(panel);
  button.setName('logout_button');
  button.SetCaption('Logout');
  button.setOnClick(@Self._LogoutButton);
  button.SetLeft(TControl.AdjustToDPI(10));
  button.SetTop(panel.getHeight() - TControl.AdjustToDPI(35));
  button.setWidth(TControl.AdjustToDPI(150));
  button.setHeight(TControl.AdjustToDPI(30));

  button.Create(panel);
  button.setName('script_open_button');
  button.SetCaption('Open script');
  button.SetOnClick(@Self._OpenScriptEx);
  button.setWidth(TControl.AdjustToDPI(150));
  button.setHeight(TControl.AdjustToDPI(30));
  button.SetTop(panel.getHeight() - TControl.AdjustToDPI(70));
  button.SetLeft(panel.getWidth() - TControl.AdjustToDPI(10) - button.getWidth());

  button.Create(panel);
  button.setName('open_rl_button');
  button.SetCaption('Install RuneLite Profile');
  button.setOnClick(@Self._InstallProfile);
  button.setWidth(TControl.AdjustToDPI(150));
  button.setHeight(TControl.AdjustToDPI(30));
  button.SetTop(panel.getHeight() - TControl.AdjustToDPI(35));
  button.SetLeft(panel.getWidth() - TControl.AdjustToDPI(10) - button.getWidth());

  launcherRev.Create(panel);
  launcherRev.setName('launcher_revision_label');
  launcherRev.setCaption('Launcher revision: ' + ToStr(WaspUpdater.Launcher.Revision));
  launcherRev.SetTop(panel.getHeight() - TControl.AdjustToDPI(30));
  launcherRev.setLeft(Self.Size.X div 2 - launcherRev.GetTrueWidth() div 2);

  Self.SetupVersionsPanel(panel, user.GetTop());
  Self.SetupScriptPanel(
    panel,
    [scriptsList.GetRight() + TControl.AdjustToDPI(30),
     scriptsList.GetTop()   + TControl.AdjustToDPI(30)]
  );
end;

procedure TWaspForm.SetupExtraPanel(parent: TPanel);
var
  panel: TPanel;
  button: TButton;
  info: TLabel;
begin
  panel.Create(parent);
  panel.setName('extra_panel');
  panel.setCaption('');
  panel.setWidth(Self.Size.X);
  panel.setHeight(Self.Size.Y);
  panel.setBevelWidth(0);

  info.Create(panel);
  info.SetCaption(
    '       Work in progress!' + LineEnding + LineEnding +
    'More stuff will be added here in the future!' + LineEnding +
    'Thank you for using WaspScripts :)' + LineEnding + LineEnding +
    'Sorry if things have been bumpy for a few days!'
  );
  info.SetFontSize(60);
  info.setTop(Self.Size.Y div 3);
  info.setLeft(Self.Size.X div 3);

  button.Create(panel);
  button.setName('all_autoupdate_button');
  button.setCaption('Update All Scripts');
  button.SetTop(TControl.AdjustToDPI(70));
  button.setLeft(TControl.AdjustToDPI(10));
  button.setWidth(TControl.AdjustToDPI(150));
  button.setHeight(TControl.AdjustToDPI(30));
  button.setOnClick(@Self._UpdateScripts);

  button.Create(panel);
  button.setName('clear_cache_button');
  button.setCaption('Clear cache');
  button.SetTop(TControl.AdjustToDPI(70));
  button.setLeft(TControl.AdjustToDPI(200));
  button.setWidth(TControl.AdjustToDPI(150));
  button.setHeight(TControl.AdjustToDPI(30));
  button.setOnClick(@Self._ClearCache);

  button.Create(panel);
  button.setName('extra_button');
  button.setCaption('Scripts');
  button.SetTop(panel.getHeight() - TControl.AdjustToDPI(70));
  button.setLeft(TControl.AdjustToDPI(10));
  button.setWidth(TControl.AdjustToDPI(150));
  button.setHeight(TControl.AdjustToDPI(30));
  button.setOnClick(@Self._PanelSwapClick);

  button.Create(panel);
  button.setName('logout_button');
  button.SetCaption('Logout');
  button.setOnClick(@Self._LogoutButton);
  button.SetLeft(TControl.AdjustToDPI(10));
  button.SetTop(panel.getHeight() - TControl.AdjustToDPI(35));
  button.setWidth(TControl.AdjustToDPI(150));
  button.setHeight(TControl.AdjustToDPI(30));

  panel.setVisible(False);
  panel.setEnabled(False);
end;

procedure TWaspForm.SetupMainPanel(form: TForm);
var
  panel: TPanel;
begin
  panel.Create(form);
  panel.setName('main_panel');
  panel.setCaption('');
  panel.setWidth(Self.Size.X);
  panel.setHeight(Self.Size.Y);
  panel.setBevelWidth(0);
  Self.SetupScriptsPanel(panel);
  Self.SetupExtraPanel(panel);
end;


procedure TWaspForm.OnShow(sender: TObject);
begin
  {$IFDEF WINDOWS}
  SetWindowDarkTitleBar(TForm(sender).getHandle());
  Self.SetAllChildsDarkTheme();
  {$ENDIF}

  case WaspClient.IsLoggedIn() of
    True:  Self.HandleLogin(Self.Form.GetChild('login_panel'));
    False: Self.HandleLogout(Self.Form.GetChild('main_panel'));
  end;
end;

procedure TWaspForm.Setup();
var
  launcherRev: TLabel;
begin
  Self.Size := [TControl.AdjustToDPI(900), TControl.AdjustToDPI(600)];

  Self.Form.Init(nil);
  Self.Form.SetName('wasp_form');
  Self.Form.setCaption('WaspScripts');
  Self.Form.setWidth(Self.Size.X);
  Self.Form.setHeight(Self.Size.Y);
  Self.Form.getConstraints().SetInterfaceConstraints(Self.Size.X, Self.Size.Y, Self.Size.X, Self.Size.Y);
  Self.Form.setPosition(TPosition.poScreenCenter);
  //Self.Form.setOnClose(@Self.OnClose);
  Self.Form.setColor($242322);
  Self.Form.setOnShow(@Self.OnShow);

  with Self.Form.getFont() do
  begin
    setQuality(TFontQuality.fqAntialiased);
    setPitch(TFontPitch.fpFixed);
    SetColor($F0F0F0);
  end;

  Self.ServerListener.Init(nil);
  Self.ServerListener.setName('server_listener');
  Self.ServerListener.setInterval(1500);

  Self.SetupLoginPanel(Self.Form);
  Self.SetupDiscordPanel(Self.Form);
  Self.SetupMainPanel(Self.Form);

  launcherRev.Create(Self.Form);
  launcherRev.setName('launcher_revision_label');
  launcherRev.setCaption('Launcher revision: ' + ToStr(WaspUpdater.Launcher.Revision));
  launcherRev.SetTop(Self.Form.getHeight() - TControl.AdjustToDPI(30));
  launcherRev.setLeft(TControl.AdjustToDPI(Self.Size.X) div 2 - launcherRev.getWidth());
  launcherRev.setLeft(Self.Size.X div 2 - launcherRev.GetTrueWidth() div 2);
end;

procedure TWaspForm.Show();
begin
  try
    Self.Form.ShowModal();
  except
    Writeln(GetExceptionMessage());
  finally
    Self.Form.Free();
    Self.ServerListener.setEnabled(False);
    Self.ServerListener.Free();
  end;
end;

procedure TWaspForm.Run();
var
  uxtheme: TLibHandle;
begin
  uxtheme := LoadLibrary('uxtheme.dll');
  RefreshImmersiveColorPolicyState := GetProcAddr(uxtheme, PChar(104));
  AllowDarkModeForWindow := GetProcAddr(uxtheme, PChar(133));
  AllowDarkModeForApp := GetProcAddr(uxtheme, PChar(135));
  SetPreferredAppMode := GetProcAddr(uxtheme, PChar(135));
  FlushMenuThemes := GetProcAddr(uxtheme, PChar(136));

  AllowDarkModeForApp(True);
  SetPreferredAppMode(TPreferredAppMode.AllowDark);

  Self.Setup();
  Sync(@Self.Show);

  FreeLibrary(uxtheme);
  AllowDarkModeForWindow := nil;
  AllowDarkModeForApp := nil;
  SetPreferredAppMode := nil;
  FlushMenuThemes := nil;
  RefreshImmersiveColorPolicyState := nil;
end;

var
  WaspForm: TWaspForm;



{$ENDIF}
{$ENDIF}
{$ENDIF}
{$ENDIF}
{$ENDIF}
{$ENDIF}
{$ENDIF}
{$ENDIF}
{$ENDIF}
{$ENDIF}
{$ENDIF}
{$ENDIF}



begin
  ClearDebug();
  WaspAsync.Setup();
  LauncherConfig.Setup(AppPath + 'Configs' + DirectorySeparator + 'launcher.json');
  WaspClient.Setup();
  WaspUpdater.Setup();
  GitHubClient.Setup();
  WaspForm.Run();
end;
